

<!DOCTYPE html>
<html lang="zh-CN" >



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#479ac7">
  <meta name="author" content="cronus">
  <meta name="keywords" content="">
  
    <meta name="description" content="C++11 特性学习笔记 关键字1. nullptr指针空值：0-&gt; NULL -&gt; nullptr典型的初始化指针将其执行空位置，比如 0 1int * ptr &#x3D; 0 &#x2F; NULL;  NULL 示例： 1234567891011121314void f(int i) &amp;#123;    std:cout &lt;&lt; &quot;invoke f(int)&quot; &amp;lt">
<meta property="og:type" content="article">
<meta property="og:title" content="C++11 特性学习笔记">
<meta property="og:url" content="https://cronusl.github.io/2022/11/24/CPP11%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Cronus">
<meta property="og:description" content="C++11 特性学习笔记 关键字1. nullptr指针空值：0-&gt; NULL -&gt; nullptr典型的初始化指针将其执行空位置，比如 0 1int * ptr &#x3D; 0 &#x2F; NULL;  NULL 示例： 1234567891011121314void f(int i) &amp;#123;    std:cout &lt;&lt; &quot;invoke f(int)&quot; &amp;lt">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-11-24T14:49:44.000Z">
<meta property="article:modified_time" content="2023-04-25T14:56:52.450Z">
<meta property="article:author" content="Cronus">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>C++11 特性学习笔记 - Cronus</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"cronusl.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Cronus‘s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/topic.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++11 特性学习笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-11-24 22:49" pubdate>
          2022年11月24日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          20k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          168 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C++11 特性学习笔记</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="C-11-特性学习笔记"><a href="#C-11-特性学习笔记" class="headerlink" title="C++11 特性学习笔记"></a>C++11 特性学习笔记</h2><hr>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="1-nullptr"><a href="#1-nullptr" class="headerlink" title="1. nullptr"></a>1. nullptr</h4><p>指针空值：0-&gt; NULL -&gt; nullptr<br>典型的初始化指针将其执行空位置，比如 0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> * ptr = <span class="hljs-number">0</span> / <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>

<p>NULL 示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>    std:cout &lt;&lt; <span class="hljs-string">&quot;invoke f(int)&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">char</span> *p)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;invoke f(char*)&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">f</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">f</span>(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">f</span>((<span class="hljs-type">char</span>*)<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<span id="more"></span>

<p>NULL 在不同编译环境的定义&lt;stddef.h&gt;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined (_STDDEF_H) || defined (__need_NULL)</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> NULL		<span class="hljs-comment">/* in case &lt;stdio.h&gt; has defined it. */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__GNUG__) &amp;&amp; __GNUG__ &gt;= 3</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL __null</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span>   <span class="hljs-comment">/* G++ */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __cplusplus</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL ((void *)0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span>   <span class="hljs-comment">/* C++ */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _WIN64</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL 0LL</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* W64 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* C++ */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>  <span class="hljs-comment">/* G++ */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span>	<span class="hljs-comment">/* NULL not defined and &lt;stddef.h&gt; or need NULL.  */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span>	__need_NULL</span><br></code></pre></td></tr></table></figure>

<p>NULL 示例结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span> <span class="hljs-function">invoke <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><span class="hljs-function">2. 编译失败/<span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><span class="hljs-function">3. invoke <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span></span><br></code></pre></td></tr></table></figure>

<p>C++11 提供 nullptr 关键字解决 NULL 带来的二义性问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">f</span>(<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">// invoke f(char*)</span><br></code></pre></td></tr></table></figure>

<p>空指针类型 nullptr_t<br>在 stddef.h 中定义 nullptr_t 类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 201103L</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _GXX_NULLPTR_T</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GXX_NULLPTR_T</span><br>  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">decltype</span><span class="hljs-params">(<span class="hljs-literal">nullptr</span>)</span> <span class="hljs-type">nullptr_t</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* C++11.  */</span></span><br></code></pre></td></tr></table></figure>

<p>定义的 nullptr_t 实例与 nullptr 是等价的<br>nullptr_t npt;<br>npt &#x3D;&#x3D; nullptr; &#x2F;&#x2F; true<br>nullptr_t 类型在 C++11 标准下的约束：</p>
<ul>
<li>nullptr_t 类型数据可以转换为任意指针类型</li>
<li>nullptr_t 类型不能转化为非指针类型</li>
<li>nullptr_t 类型不适用于算数运算表达式</li>
<li>nullptr_t 类型仅适用于&#x3D;&#x3D;，&gt;&#x3D;, &lt;&#x3D;关系运算表达式时返回 true</li>
</ul>
<h4 id="2-auto"><a href="#2-auto" class="headerlink" title="2. auto"></a>2. auto</h4><p>auto 自动推导数据类型，可以简化初始化复杂类型变量的声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> a = <span class="hljs-number">1</span>; <span class="hljs-comment">// a -&gt; int</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">auto</span> b = <span class="hljs-built_in">f</span>(); <span class="hljs-comment">// b -&gt; double</span><br>std::vector&lt;std::string&gt; vs;<br><span class="hljs-comment">// std::vector&lt;std::string&gt;::iterator begin = vs.begin();</span><br><span class="hljs-keyword">auto</span> begin = vs.<span class="hljs-built_in">begin</span>();<br></code></pre></td></tr></table></figure>

<p>避免类型声明错误，C++中存着很多隐式或者用户自定义的类型转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PI</span> &#123;<br>  <span class="hljs-type">double</span> <span class="hljs-keyword">operator</span>* (<span class="hljs-type">float</span> v) &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>)val * v;<br>  &#125;<br><br>  <span class="hljs-type">const</span> <span class="hljs-type">float</span> val = <span class="hljs-number">3.1415927f</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">float</span> radius = <span class="hljs-number">1.7e10</span>;<br>  PI pi;<br>  <span class="hljs-keyword">auto</span> circumference = <span class="hljs-number">2</span> * (pi * radius);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>PI 内部设计避免数据上溢或者精度降低返回 double 类型数据，在 main 函数如果不小心使用 float 声明 circumference 就会破坏原本的设计，而使用 auto 可以编译器自动推导避免问题</p>
<p>auto 的在 C++11 标准中的约束：</p>
<ul>
<li>auto 不能用作函数形参类型</li>
<li>非静态成员变量的类型不能为 auto</li>
<li>auto 不能用于声明数组</li>
<li>auto 不能用于实例化模板时作为参数</li>
</ul>
<h4 id="3-decltype"><a href="#3-decltype" class="headerlink" title="3. decltype"></a>3. decltype</h4><p>decltype 用于类型推导, typeid 用于运行时获取变量的 type_info 信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">decltype</span>(i) j = <span class="hljs-number">0</span>;<br>std::count &lt;&lt; <span class="hljs-built_in">typeid</span>(j).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl; <span class="hljs-comment">// int</span><br><br><span class="hljs-type">float</span> a = <span class="hljs-number">1.0</span>;<br><span class="hljs-type">double</span> b = <span class="hljs-number">2.0</span>;<br><br><span class="hljs-keyword">decltype</span>(a + b) c;<br>std::count &lt;&lt; <span class="hljs-built_in">typeid</span>(c).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl; <span class="hljs-comment">// double</span><br></code></pre></td></tr></table></figure>

<p>decltype 与 auto 有相同的作用，不过 decltype 更加灵活，可以用于推导表达式<br>结合 typedef 与 using 组合转化为符合具体含义的表达式提高代码的可读性和可维护性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector&lt;std::string&gt; vs;<br><span class="hljs-keyword">using</span> VecType = <span class="hljs-keyword">decltype</span>(vs.<span class="hljs-built_in">begin</span>());<br></code></pre></td></tr></table></figure>

<p>decltype 推导规则</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">decltype</span>(i) a;      <span class="hljs-comment">// init</span><br><span class="hljs-keyword">decltype</span>((i)) b;    <span class="hljs-comment">// int&amp; 编译失败</span><br></code></pre></td></tr></table></figure>

<p>decltype(e)获取类型时编译器推导规则:</p>
<ul>
<li>如果 e 没有带括号的标记符表达式或者类成员时，e 就是所有命名实体的类型, 另外如果 e 为重载函数，则编译错误</li>
<li>否则，e 类型为 T, e 如果是一个将亡值，decltype(e)的类型为 T&amp;&amp;</li>
<li>否则，e 类型为 T，e 如果是一个左值，decltype(e)的类型为 T&amp;</li>
<li>否则，e 类型为 T，decltype(e)的类型为 T</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">4</span>;<br>​​​​​​​​<span class="hljs-type">int</span> arr[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>​​​​​​​​<span class="hljs-type">int</span> *ptr = arr;<br>​​​​​​​​<span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> &#123; <span class="hljs-type">double</span> d; &#125; s;<br>​​​​​​​​<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Overloaded</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br>​​​​​​​​<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Overloaded</span><span class="hljs-params">(<span class="hljs-type">char</span>)</span></span>;       <span class="hljs-comment">// 重载的函数</span><br>​​​​​​​​<span class="hljs-function"><span class="hljs-type">int</span> &amp;&amp; <span class="hljs-title">RvalRef</span><span class="hljs-params">()</span></span>;<br>​​​​​​​​<span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">bool</span> <span class="hljs-title">Func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><br>​​​​​​​​<span class="hljs-comment">// 规则1: 单个标记符表达式以及访问类成员，推导为本类型</span><br>​​​​​​​​<span class="hljs-keyword">decltype</span>(arr) var1;              <span class="hljs-comment">// int[5], 标记符表达式</span><br>​​​​​​​​<span class="hljs-keyword">decltype</span>(ptr) var2;              <span class="hljs-comment">// int*, 标记符表达式</span><br>​​​​​​​​<span class="hljs-keyword">decltype</span>(s.d) var4;              <span class="hljs-comment">// double, 成员访问表达式</span><br>​​​​​​​​<span class="hljs-keyword">decltype</span>(Overloaded) var5;       <span class="hljs-comment">// 无法通过编译，是个重载的函数</span><br><br>​​​​​​​​<span class="hljs-comment">// 规则2: 将亡值，推导为类型的右值引用</span><br>​​​​​​​​<span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">RvalRef</span>()) var6 = <span class="hljs-number">1</span>;   <span class="hljs-comment">// int&amp;&amp;</span><br><br>​​​​​​​​<span class="hljs-comment">// 规则3: 左值，推导为类型的引用</span><br>​​​​​​​​<span class="hljs-keyword">decltype</span>(<span class="hljs-literal">true</span> ? i : i) var7 = i;       <span class="hljs-comment">// int&amp;, 三元运算符，这里返回一个i的左值</span><br>​​​​​​​​<span class="hljs-keyword">decltype</span>((i)) var8 = i;                <span class="hljs-comment">// int&amp;, 带圆括号的左值</span><br>​​​​​​​​<span class="hljs-keyword">decltype</span>(++i) var9 = i;                <span class="hljs-comment">// int&amp;, ++i返回i的左值</span><br>​​​​​​​​<span class="hljs-keyword">decltype</span>(arr[<span class="hljs-number">3</span>]) var10 = i;            <span class="hljs-comment">// int&amp; []操作返回左值</span><br>​​​​​​​​<span class="hljs-keyword">decltype</span>(*ptr)  var11 = i;             <span class="hljs-comment">// int&amp; *操作返回左值</span><br>​​​​​​​​<span class="hljs-keyword">decltype</span>(<span class="hljs-string">&quot;hello&quot;</span>) var12 = <span class="hljs-string">&quot;hello&quot;</span>;       <span class="hljs-comment">// const char(&amp;)[6], 字符串字面常量为左值</span><br><br>​​​​​​​​<span class="hljs-comment">// 规则4：以上都不是，推导为本类型</span><br>​​​​​​​​<span class="hljs-keyword">decltype</span>(<span class="hljs-number">1</span>) var13;                 <span class="hljs-comment">// int, 除字符串外字面常量为右值</span><br>​​​​​​​​<span class="hljs-keyword">decltype</span>(i++) var14;               <span class="hljs-comment">// int, i++返回右值</span><br><span class="hljs-keyword">decltype</span>((<span class="hljs-built_in">Func</span>(<span class="hljs-number">1</span>))) var15;         <span class="hljs-comment">// const bool, 圆括号可以忽略</span><br></code></pre></td></tr></table></figure>

<h4 id="4-using"><a href="#4-using" class="headerlink" title="4. using"></a>4. using</h4><p>C++11 之前一般用于引用命名空间<br>using namespace std;</p>
<p>C++11 可以用于定义数据类型别名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> EASCalendarPtr = std::shared_ptr&lt;EASCalendar&gt;;<br><br>常规使用<span class="hljs-keyword">typedef</span>定义数据类型别名<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> MyInt;<br><span class="hljs-keyword">using</span> MyInt = <span class="hljs-type">int</span>;<br><br>使用<span class="hljs-keyword">using</span>定义数据类型别名更加灵活<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">using</span> CustomMap = std::Map&lt;T, std::string&gt;;<br><br>CustomMap&lt;<span class="hljs-type">int</span>&gt; numberCustomMap;<br>CustomMap&lt;std::string&gt; stringCustomMap;<br></code></pre></td></tr></table></figure>

<p>C++11 使用 using 实现继承构造函数<br>通常情况下派生类可以自动获取基类定义的 public 虚函数和纯虚函数，对于构造函数也不例外，派生类如果需要使用基类的构造函数需要显示声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i)&#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> i): <span class="hljs-built_in">A</span>(i)&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>一旦基类再定义其他的构造函数，派生类如果需要使用就需要显示定义并透传基类的构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i)&#123;&#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">double</span> j)&#123;&#125;<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> std::string&amp; s)&#123;&#125;<br>    ...<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> i): <span class="hljs-built_in">A</span>(i)&#123;&#125;<br>    <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">double</span> j):<span class="hljs-built_in">A</span>(i,j)&#123;&#125;<br>    <span class="hljs-built_in">B</span>(<span class="hljs-type">const</span> std::string&amp;s):<span class="hljs-built_in">A</span>(s)&#123;&#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在 C++11 中可以使用 using 来声明继承基类的构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A  &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> A:A;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>C++11 标准继承构造函数被设计为跟派生类中的各种类默认函数（默认构造、析构、拷贝构造等）一样，是隐式声明的。这意味着如果一个继承构造函数不被相关代码使用，编译器不会为其产生真正的函数代码,这无疑比“透传”方案总是生成派生类的各种构造函数更加节省目标代码空间</p>
<p>如果继承的基类构造函数无法满足派生类的需求，可以通过再实现一个构造函数或者通过成员变量初始化的方式处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A  &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> A::A;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_d;<br>&#125;<br><br><span class="hljs-number">1.</span> 自定义构造函数<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A  &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> A:A;<br>    <span class="hljs-built_in">int</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> d): <span class="hljs-built_in">A</span>(i), <span class="hljs-built_in">m_d</span>(d) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_d;<br>&#125;；<br><br><span class="hljs-number">2.</span> 成员变量初始化<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>: <span class="hljs-keyword">public</span> A  &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> A::A;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> m_d = <span class="hljs-number">0</span>;<br>&#125;；<br></code></pre></td></tr></table></figure>

<p>多重继承出现继承冲突，通过显示定义继承类中冲突的构造函数处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123; <span class="hljs-keyword">public</span>: <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span>)&#123;&#125;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123; <span class="hljs-keyword">public</span>: <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span>)&#123;&#125;&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>: <span class="hljs-keyword">public</span> A, <span class="hljs-keyword">public</span> B &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> A::A;<br>  <span class="hljs-keyword">using</span> B::B;<br><br>  <span class="hljs-built_in">C</span>(<span class="hljs-type">int</span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-default"><a href="#5-default" class="headerlink" title="5. default"></a>5. default</h4><p>C++中自定义类的构造函数后编译器不再自动生成默认构造函数，使用 default 生成默认构造函数，<br>C++11 标准用&#x3D;default 修饰的函数为显示缺省函数,default 可以在类中定义修饰函数，也可以在定义之外修饰函数，这样可以在不同的实现文件中实现构造函数，从而可以切换不同的实现版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">DefaultClass</span>() = <span class="hljs-keyword">default</span>;<br><br>  DefaultClass&amp; <span class="hljs-keyword">operator</span> = (<span class="hljs-type">const</span> DefaultClass&amp; );<br>&#125;<br><br>DefaultClass&amp; DefaultClass::<span class="hljs-keyword">operator</span> = (<span class="hljs-type">const</span> DefaultClass&amp;) = <span class="hljs-keyword">default</span>;<br></code></pre></td></tr></table></figure>

<h4 id="6-delete"><a href="#6-delete" class="headerlink" title="6. delete"></a>6. delete</h4><p>C++11 标准用&#x3D;delete 修饰的函数为显示删除函数，删除的函数明确禁止类型实例调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">禁止类实例拷贝，C++<span class="hljs-number">11</span>之前通过<span class="hljs-keyword">private</span>实现，C++<span class="hljs-number">11</span>可以通过<span class="hljs-keyword">delete</span>实现<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NoCopy</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">NoCopy</span>() = <span class="hljs-keyword">default</span>;<br>  <span class="hljs-built_in">NoCopy</span>(<span class="hljs-type">const</span> NoCopy&amp;) = <span class="hljs-keyword">delete</span>;<br>  NoCopy&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> NoCopy&amp;) = <span class="hljs-keyword">delete</span>;<br>  <span class="hljs-built_in">NoCopy</span>(NoCopy&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br>  NoCopy&amp; <span class="hljs-keyword">operator</span>=(NoCopy&amp;&amp;) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>显示删除自定义类型的 operator new 操作符禁止在堆上分配该类型的对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NoHeapAlloc</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(std::<span class="hljs-type">size_t</span>)</span> </span>= <span class="hljs-keyword">delete</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  NoHeapAlloc nha;   <span class="hljs-comment">// 栈变量正常分配</span><br>  NoHeapAlloc *pnha;  <span class="hljs-comment">// 编译失败，调用已删除的函数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>显示删除析构函数限制自定义类型在栈上或者静态构造</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span>* p;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NoStackAlloc</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ~<span class="hljs-built_in">NoStackAlloc</span>() = <span class="hljs-keyword">delete</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">sizeof</span>(NoStackAlloc) + <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)];<br><br>  NoStackAlloc nsa;  <span class="hljs-comment">// 编译失败</span><br>  <span class="hljs-keyword">new</span> (p) <span class="hljs-built_in">NoStackAlloc</span>();<span class="hljs-comment">// placement new, 仅调用构造函数生成对象，非常规构建单实例</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="7-constexpr"><a href="#7-constexpr" class="headerlink" title="7. constexpr"></a>7. constexpr</h4><p>常量表达式是指值不会改变并且在编译过程中就能得到计算结果的表达式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-comment">// 是常量表达式</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> b = a + <span class="hljs-number">1</span>; <span class="hljs-comment">// 是常量表达式</span><br><span class="hljs-type">int</span> c = <span class="hljs-number">11</span>;  <span class="hljs-comment">// 非常量表达式</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> d = <span class="hljs-built_in">getValue</span>(); <span class="hljs-comment">// 非常量表达式</span><br></code></pre></td></tr></table></figure>

<p>C++11 之前如果是在比较复杂的系统中几乎不能分辨一个初始值到底是不是常量表达式，C++11 提供了 constexpr 关键字以便编译器在编译时验证变量是否是常量表达式，使用 constexpr 声明的变量一定是一个常量，而且必须用常量表达式初始化:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> b = a + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> c = <span class="hljs-built_in">getValue</span>(); <span class="hljs-comment">// 只有当getValue()是一个constexpr函数编译才会成功</span><br></code></pre></td></tr></table></figure>

<p>指针与 constexpr<br>如果使用 constexpr 声明一个指针，则 constexpr 仅对指针有效，与指针所有指的对象无关：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = <span class="hljs-literal">nullptr</span>;        <span class="hljs-comment">// p是指向整型常量的指针</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> *q = <span class="hljs-literal">nullptr</span>;    <span class="hljs-comment">// q是指向整数的常量指针</span><br></code></pre></td></tr></table></figure>

<h4 id="8-final"><a href="#8-final" class="headerlink" title="8. final"></a>8. final</h4><p>通常情况下，基类中的 public 虚函数能够被派生类重载，有时候可能并不想要被重载，在 C+11 之前是不能限制的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> voif <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>: <span class="hljs-keyword">public</span> Object &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Drived</span>: <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 编译错误</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>final 同样的对于类的继承也有相同的效果，如果确定某个类不允许再被继承，在类的声明中添加 final</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">XXXManager</span> <span class="hljs-keyword">final</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// 编译错误</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DrivedManager</span>: <span class="hljs-keyword">public</span> XXXManager &#123;<br><br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="9-override"><a href="#9-override" class="headerlink" title="9. override"></a>9. override</h4><p>C++11 中引用 override 关键字帮助程序员写继承结构复杂的类型，引入了虚函数描述符 override,如果派生类在虚函数声明时使用了 override，那么该函数必须重载基类中的同名函数，否则编译时无法通过</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">​​​​​​​​​​<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base</span> &#123;<br>​​​​​​​​    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Turing</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>​​​​​​​​    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>​​​​​​​​    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">VNeumann</span><span class="hljs-params">(<span class="hljs-type">int</span> g)</span> </span>= <span class="hljs-number">0</span>;<br>​​​​​​​​    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">DKnuth</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>​​​​​​​​    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span>;<br>​​​​​​​​&#125;;<br><br>​​​​​​​​<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DerivedMid</span>: <span class="hljs-keyword">public</span> Base &#123;<br>​​​​​​​​    <span class="hljs-comment">// void VNeumann(double g);</span><br>​​​​​​​​    <span class="hljs-comment">// 新增一个VNeumann函数版本</span><br>​​​​​​​​&#125;;<br><br>​​​​​​​​<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DerivedTop</span> : <span class="hljs-keyword">public</span> DerivedMid &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Turing</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>​​​​​​​​    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dikjstra</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;              <span class="hljs-comment">// 无法通过编译，拼写错误，并非重载</span><br>​​​​​​​​    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">VNeumann</span><span class="hljs-params">(<span class="hljs-type">double</span> g)</span> <span class="hljs-keyword">override</span></span>;      <span class="hljs-comment">// 无法通过编译，参数不一致，并非重载</span><br>​​​​​​​​    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DKnuth</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;                <span class="hljs-comment">// 无法通过编译，常量性不一致，并非重载</span><br>​​​​​​​​    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;                 <span class="hljs-comment">// 无法通过编译，非虚函数重载</span><br>​​​​​​​​&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>C++类中包含指针成员，在使用拷贝构造时很容易出现内存泄露问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HasPtrMem</span> &#123;<br>​​​​​​​​<span class="hljs-keyword">public</span>:<br>​​​​​​​​    <span class="hljs-built_in">HasPtrMem</span>(): <span class="hljs-built_in">d</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">0</span>)) &#123;&#125;<br>​​​​​​​​    <span class="hljs-built_in">HasPtrMem</span>(<span class="hljs-type">const</span> HasPtrMem &amp; h):<br>​​​​​​​​        <span class="hljs-built_in">d</span>(h.d) &#123;&#125;<br>​​​​​​​​    ～<span class="hljs-built_in">HasPtrMem</span>() &#123; <span class="hljs-keyword">delete</span> d; &#125;<br>​​​​​​​​    <span class="hljs-type">int</span> * d;<br>​​​​​​​​&#125;;<br>​​​​​​​​<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>​​​​​​​​    HasPtrMem a;<br>​​​​​​​​    <span class="hljs-function">HasPtrMem <span class="hljs-title">b</span><span class="hljs-params">(a)</span></span>;<br>​​​​​​​​    cout &lt;&lt; *a.d &lt;&lt; endl;    <span class="hljs-comment">// 0</span><br>​​​​​​​​    cout &lt;&lt; *b.d &lt;&lt; endl;    <span class="hljs-comment">// 0</span><br>​​​​​​​​&#125;    <span class="hljs-comment">// 正常析构</span><br></code></pre></td></tr></table></figure>

<p>在函数中 b 实例是调用拷贝构造函数创建，拷贝构造函数作用类似于 memcpy 按位拷贝，这种就构造了 a.d 和 b.d 都指向同一块内存区域，当 main 函数作用域结束后，a 和 b 的析构函数被调用，当 b 析构后，a 中的成员 d 指针就成了悬挂指针，再调用析构函数时出现内存重复释放问题，这样的拷贝构造也就是浅拷贝，通常的处理方法是通过深拷贝</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">HasPtrMem</span>(<span class="hljs-type">const</span> HasPtrMem &amp; h):<br>​​​​​​​​        <span class="hljs-built_in">d</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*h.d)) &#123;&#125;<br></code></pre></td></tr></table></figure>

<p>深拷贝虽然能解决此类问题，但同样也带来性能问题，如果当成员 d 不是简单的 int 指针，而是占用内存比较大的类型指针，通过深拷贝的方式势必造成内存冗余问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HasPtrMem</span> &#123;<br>​​​​​​​​<span class="hljs-keyword">public</span>:<br>​​​​​​​​    <span class="hljs-built_in">HasPtrMem</span>(): <span class="hljs-built_in">d</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">0</span>)) &#123;<br>​​​​​​​​        cout &lt;&lt; <span class="hljs-string">&quot;Construct: &quot;</span> &lt;&lt; ++n_cstr &lt;&lt; endl;<br>​​​​​​​​    &#125;<br>​​​​​​​​    <span class="hljs-built_in">HasPtrMem</span>(<span class="hljs-type">const</span> HasPtrMem &amp; h): <span class="hljs-built_in">d</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*h.d)) &#123;<br>​​​​​​​​        cout &lt;&lt; <span class="hljs-string">&quot;Copy construct: &quot;</span> &lt;&lt; ++n_cptr &lt;&lt; endl;<br>​​​​​​​​    &#125;<br>​​​​​​​​    ～<span class="hljs-built_in">HasPtrMem</span>() &#123;<br>​​​​​​​​        cout &lt;&lt; <span class="hljs-string">&quot;Destruct: &quot;</span> &lt;&lt; ++n_dstr &lt;&lt; endl;<br>​​​​​​​​    &#125;<br>​​​​​​​​    <span class="hljs-type">int</span> * d;<br>​​​​​​​​    <span class="hljs-type">static</span> <span class="hljs-type">int</span> n_cstr;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> n_dstr;<br>​​​​​​​​    <span class="hljs-type">static</span> <span class="hljs-type">int</span> n_cptr;<br>​​​​​​​​&#125;;<br>​​​​​​​​<span class="hljs-type">int</span> HasPtrMem::n_cstr = <span class="hljs-number">0</span>;<br>​​​​​​​​<span class="hljs-type">int</span> HasPtrMem::n_dstr = <span class="hljs-number">0</span>;<br>​​​​​​​​<span class="hljs-type">int</span> HasPtrMem::n_cptr = <span class="hljs-number">0</span>;<br>​​​​​​​​<span class="hljs-function">HasPtrMem <span class="hljs-title">GetTemp</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">HasPtrMem</span>(); &#125;<br>​​​​​​​​<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>​​​​​​​​    HasPtrMem a = <span class="hljs-built_in">GetTemp</span>();<br>​​​​​​​​&#125;<br></code></pre></td></tr></table></figure>

<p>示例代码构造函数、拷贝构造函数、析构函数分别调用多少次？</p>
<details>
<summary>结果</summary>

<p>Construct: 1<br>​​​​​​​​Copy construct: 1<br>​​​​​​​​Destruct: 1<br>​​​​​​​​Copy construct: 2<br>​​​​​​​​Destruct: 2<br>​​​​​​​​Destruct: 3​​</p>
<p>这里构造函数被调用了一次，这是在 GetTemp 函数中 HasPtrMem()表达式显式地调用了构造函数而打印出来的。而拷贝构造函数则被调用了两次。这两次一次是从 GetTemp 函数中 HasPtrMem()生成的变量上拷贝构造出一个临时值，以用作 GetTemp 的返回值，而另外一次则是由临时值构造出 main 中变量 a 调用的。对应地，析构函数也就调用了 3 次</p>
</details>

<p><strong>注意</strong> ： 编译器可能有优化移除了多余的构造函数调用，使用-fno-elide-constructors 编译选项禁止优化可以打印构造函数调用过程</p>
<p>这样的过程调用确实比较浪费资源，C++11 中可以通过移动构造函数来‘窃取’临时变量中的资源，这个过程成为移动语义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HasPtrMem</span> &#123;<br>​​​​​​​​<span class="hljs-keyword">public</span>:<br>​​​​​​​​    <span class="hljs-built_in">HasPtrMem</span>(): <span class="hljs-built_in">d</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">3</span>)) &#123;<br>​​​​​​​​        cout &lt;&lt; <span class="hljs-string">&quot;Construct: &quot;</span> &lt;&lt; ++n_cstr &lt;&lt; endl;<br>​​​​​​​​    &#125;<br>​​​​​​​​    <span class="hljs-built_in">HasPtrMem</span>(<span class="hljs-type">const</span> HasPtrMem &amp; h): <span class="hljs-built_in">d</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*h.d)) &#123;<br>​​​​​​​​        cout &lt;&lt; <span class="hljs-string">&quot;Copy construct: &quot;</span> &lt;&lt; ++n_cptr &lt;&lt; endl;<br>​​​​​​​​    &#125;<br>​​​​​​​​    <span class="hljs-built_in">HasPtrMem</span>(HasPtrMem &amp;&amp; h): <span class="hljs-built_in">d</span>(h.d) &#123; <span class="hljs-comment">// 移动构造函数</span><br>​​​​​​​​        h.d = <span class="hljs-literal">nullptr</span>;                      <span class="hljs-comment">// 将临时值的指针成员置空</span><br>​​​​​​​​        cout &lt;&lt; <span class="hljs-string">&quot;Move construct: &quot;</span> &lt;&lt; ++n_mvtr &lt;&lt; endl;<br>​​​​​​​​    &#125;<br>​​​​​​​​      ～<span class="hljs-built_in">HasPtrMem</span>() &#123;<br>​​​​​​​​          <span class="hljs-keyword">delete</span> d;<br>​​​​​​​​          cout &lt;&lt; <span class="hljs-string">&quot;Destruct: &quot;</span> &lt;&lt; ++n_dstr &lt;&lt; endl;<br>​​​​​​​​      &#125;<br>​​​​​​​​      <span class="hljs-type">int</span> * d;<br>​​​​​​​​      <span class="hljs-type">static</span> <span class="hljs-type">int</span> n_cstr;<br>​​​​​​​​      <span class="hljs-type">static</span> <span class="hljs-type">int</span> n_dstr;<br>​​​​​​​​      <span class="hljs-type">static</span> <span class="hljs-type">int</span> n_cptr;<br>​​​​​​​​      <span class="hljs-type">static</span> <span class="hljs-type">int</span> n_mvtr;<br>​​​​​​​​  &#125;;<br>​​​​​​​​  <span class="hljs-type">int</span> HasPtrMem::n_cstr = <span class="hljs-number">0</span>;<br>​​​​​​​​  <span class="hljs-type">int</span> HasPtrMem::n_dstr = <span class="hljs-number">0</span>;<br>​​​​​​​​  <span class="hljs-type">int</span> HasPtrMem::n_cptr = <span class="hljs-number">0</span>;<br>​​​​​​​​  <span class="hljs-type">int</span> HasPtrMem::n_mvtr = <span class="hljs-number">0</span>;<br>​​​​​​​​  <span class="hljs-function">HasPtrMem <span class="hljs-title">GetTemp</span><span class="hljs-params">()</span> </span>&#123;<br>​​​​​​​​      HasPtrMem h;<br>​​​​​​​​      cout &lt;&lt; <span class="hljs-string">&quot;Resource from &quot;</span> &lt;&lt;   __func__ &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; hex &lt;&lt; h.d &lt;&lt; endl;<br>​​​​​​​​      <span class="hljs-keyword">return</span> h;<br>​​​​​​​​  &#125;<br><br>​​​​​​​​  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>​​​​​​​​  HasPtrMem a = <span class="hljs-built_in">GetTemp</span>();<br>  cout &lt;&lt; <span class="hljs-string">&quot;Resource from &quot;</span> &lt;&lt;   __func__ &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; hex &lt;&lt; a.d &lt;&lt; endl;<br>​​​​​​​​ &#125;<br></code></pre></td></tr></table></figure>

<p>调用结果</p>
<figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">Construct</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1​​</span><br><span class="hljs-attribute">​​​​​​​​​​Resource from GetTemp</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0x823010</span><br><span class="hljs-attribute">​​​​​​​​Move construct</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1</span><br><span class="hljs-attribute">Destruct</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1</span><br><span class="hljs-attribute">​​​​​​​​Move construct</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2​​​​​​​</span><br><span class="hljs-attribute">​Destruct</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2</span><br><span class="hljs-attribute">​​​​​​​​Resource from main</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0x823010</span><br><span class="hljs-attribute">Destruct</span><span class="hljs-punctuation">:</span> <span class="hljs-string">3​​</span><br></code></pre></td></tr></table></figure>

<p>可以看到，这里没有调用拷贝构造函数，而是调用了两次移动构造函数，移动构造的结果是，GetTemp 中的 h 的指针成员 h.d 和 main 函数中的 a 的指针成员 a.d 的值是相同的，即 h.d 和 a.d 都指向了相同的堆地址内存。该堆内存在函数返回的过程中，不会调用析构函数释放，取而代之地，成为了赋值表达式中的变量 a 的资源</p>
<p>移动构造函数怎么触发的呢？</p>
<details>
通过上述代码分析是返回了HasPtrMem的临时对象触发移动构造函数
</details>

<p>左值、右值与右值引用<br>左值与右值是如何区分的呢？ 一个不严谨的区分方式是通过在赋值表达式中通过判断出现在&#x3D;左边的称为左值，而在右边的值称为右值</p>
<p>不过在 C++中一个被广泛认同的说法是，可以取地址并且有名字的是左值，不能取地址以及没有名字就是右值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> c = a + b;<br><span class="hljs-comment">// c是左值，(a+b)是右值</span><br></code></pre></td></tr></table></figure>

<p>C++11 右值由将亡值和纯右值构成<br>将亡值：与右值引用相关的表达式，比如返回右值引用的 T&amp;&amp;的函数返回值，std::move 返回值等<br>纯右值：非引用返回值函数返回的临时变量，运算表达式返回临时值，不跟对象关联的字面量值</p>
<p>在 C++中右值引用就是对一个右值进行引用的类型，实际上，右值通常是不具备名字，也只能通过引用的方式来与之关联</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">T&amp;&amp; a = <span class="hljs-built_in">ReturnRValue</span>();<br><br>T b = <span class="hljs-built_in">ReturnRValue</span>();<br></code></pre></td></tr></table></figure>

<p>a 和 b 调用 ReturnRvalue()返回右值函数区别在，a 是右值引用类型能过减少一次对象的构造和析构，直接绑定临时变量，通常情况下右值引用不能绑定任何左值变量，否则编译无法通过</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Copyable</span> &#123;<br>​​​​​​​​      <span class="hljs-built_in">Copyable</span>() &#123;&#125;<br>​​​​​​​​      <span class="hljs-built_in">Copyable</span>(<span class="hljs-type">const</span> Copyable &amp;o) &#123;<br>​​​​​​​​          cout &lt;&lt; <span class="hljs-string">&quot;Copied&quot;</span> &lt;&lt; endl;<br>​​​​​​​​      &#125;<br>      <span class="hljs-built_in">Copyable</span>(Copyable &amp;&amp;o) &#123;<br>​​​​​​​​          cout &lt;&lt; <span class="hljs-string">&quot;Move Copied&quot;</span> &lt;&lt; endl;<br>​​​​​​​​      &#125;<br>​​​​​​​​  &#125;;<br>​​​​​​​​  <span class="hljs-function">Copyable <span class="hljs-title">ReturnRvalue</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Copyable</span>(); &#125;<br>​​​​​​​​  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AcceptVal</span><span class="hljs-params">(Copyable)</span> </span>&#123;&#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AcceptRef</span><span class="hljs-params">(Copyable &amp;&amp;)</span> </span>&#123;&#125;<br>​​​​​​​​  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>​​​​​​​​      cout &lt;&lt; <span class="hljs-string">&quot;Pass by value: &quot;</span> &lt;&lt; endl;<br>​​​​​​​​      <span class="hljs-built_in">AcceptVal</span>(<span class="hljs-built_in">ReturnRvalue</span>()); <span class="hljs-comment">// 临时值被拷贝传入</span><br>​​​​​​​​      cout &lt;&lt; <span class="hljs-string">&quot;Pass by reference: &quot;</span> &lt;&lt; endl;<br>​​​​​​​​      <span class="hljs-built_in">AcceptRef</span>(<span class="hljs-built_in">ReturnRvalue</span>()); <span class="hljs-comment">// 临时值被作为引用传递</span><br>​​​​​​​​  &#125;<br></code></pre></td></tr></table></figure>

<details>
<summary>结果</summary>

<p>Pass by value:<br>Move Copied<br>Move Copied<br>Pass by reference:<br>Move Copied</p>
</details>

<p>如果去掉移动拷贝构造函数，结果会是怎样？</p>
<details>
<summary>结果</summary>

<p>Pass by value:<br>​​​​​​​​Copied<br>​​​​​​​​Copied<br>​​​​​​​​Pass by reference:<br>​​​​​​​​Copied​​</p>
</details>

<p>从结果可以得知 C++11 中在移动拷贝构造函数无法使用时可以通过拷贝构造函数来兜底，也是 C++中设计的巧妙之处，移动不成还可以拷贝</p>
<p>C++11 区分左右值模板函数</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby">std::is_lvalue_reference<br>std::is_rvalue_reference<br><br>std::cout &lt;&lt; std::is_rvalue_reference(std::string &amp;&amp;)<span class="hljs-symbol">:</span><span class="hljs-symbol">:value</span> &lt;&lt; std::endl; <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<h4 id="std-move-函数"><a href="#std-move-函数" class="headerlink" title="std::move 函数"></a>std::move 函数</h4><p>C++11 标准库<utility>提供 std::move 函数，其本身不会启动任何东西，而是将左值强制转化为右值，相当于 static_cast&lt;T&amp;&amp;&gt;(lvalue)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Moveable</span> &#123;<br>​<span class="hljs-keyword">public</span>:￼​​​​​​​​<br>    <span class="hljs-built_in">Moveable</span>():<span class="hljs-built_in">i</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">3</span>)) &#123;&#125;￼​​​​​​​​<br>    ～<span class="hljs-built_in">Moveable</span>() &#123; <span class="hljs-keyword">delete</span> i; &#125;￼​​​​​​​​<br>    <span class="hljs-built_in">Moveable</span>(<span class="hljs-type">const</span> Moveable &amp; m): <span class="hljs-built_in">i</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*m.i)) &#123; &#125;￼​​​​​​​​<br>    <span class="hljs-built_in">Moveable</span>(Moveable &amp;&amp; m):<span class="hljs-built_in">i</span>(m.i) &#123;￼​​​​​​​​<br>        m.i = <span class="hljs-literal">nullptr</span>;￼​​​​​​​​<br>    &#125;￼​​​​​​​​<br><br>    <span class="hljs-type">int</span>* i;￼​​​​​​​<br>&#125;;<br>￼<br>​​​​​​​​<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;￼​​​​​​​​<br>    Moveable a;￼​​​​​​​​<br>    <span class="hljs-function">Moveable <span class="hljs-title">c</span><span class="hljs-params">(move(a))</span></span>;     <span class="hljs-comment">// 调用移动构造函数￼​​​​​​​​</span><br>    cout &lt;&lt; *a.i &lt;&lt; endl;    <span class="hljs-comment">// 运行时错误</span><br>​​​​​​​&#125;￼<br></code></pre></td></tr></table></figure>

<p>左值 a 被 std::move 转为右值，实例化变量 c 时触发 Moveable 的移动构造函数，a.i 指针被置为 nullptr,取空指针的值触发运行时错误，从该示例中得知，调用 std::move 转化的实例并不会随这转化后立马释放，错误的使用 std::move 函数可能会导致发生严重的运行时错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HugeMem</span> &#123;<br>    ​<span class="hljs-keyword">public</span> :​ <span class="hljs-built_in">HugeMem</span>(<span class="hljs-type">int</span> size) : <span class="hljs-built_in">sz</span>(size &gt; <span class="hljs-number">0</span> ? size : <span class="hljs-number">1</span>) &#123;<br>        ​ c = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[sz];      ​<br>    &#125;<br>    ​～ <span class="hljs-built_in">HugeMem</span>() &#123; <span class="hljs-keyword">delete</span>[] c; &#125;<br>    ​<span class="hljs-built_in">HugeMem</span>(HugeMem &amp;&amp;hm) : <span class="hljs-built_in">sz</span>(hm.sz), <span class="hljs-built_in">c</span>(hm.c) &#123;<br>        ​ hm.c = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    ​ <span class="hljs-type">int</span> _ c;<br>    ​ <span class="hljs-type">int</span> sz;​<br>&#125;;<br><br>​<span class="hljs-keyword">class</span> <span class="hljs-title class_">Moveable</span> &#123;<br>    ​<span class="hljs-keyword">public</span> :​ <span class="hljs-built_in">Moveable</span>() : <span class="hljs-built_in">i</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">3</span>)), <span class="hljs-built_in">h</span>(<span class="hljs-number">1024</span>) &#123;&#125;<br>    ​ ～ <span class="hljs-built_in">Moveable</span>() &#123; <span class="hljs-keyword">delete</span> i; &#125;<br>    ​ <span class="hljs-built_in">Moveable</span>(Moveable &amp;&amp;m) :​ <span class="hljs-built_in">i</span>(m.i), <span class="hljs-built_in">h</span>(<span class="hljs-built_in">move</span>(m.h)) &#123; <span class="hljs-comment">// 强制转为右值，以调用移动构造函数 ​</span><br>        m.i = <span class="hljs-literal">nullptr</span>;​<br>    &#125;<br><br>    ​int_ i;<br>    ​HugeMem h;<br>&#125;;<br><br>​<span class="hljs-function">Moveable <span class="hljs-title">GetTemp</span><span class="hljs-params">()</span> </span>&#123;<br>    ​ Moveable tmp = <span class="hljs-built_in">Moveable</span>();<br>    ​ cout &lt;&lt; hex &lt;&lt; <span class="hljs-string">&quot;Huge Mem from &quot;</span> &lt;&lt; **func * *​ &lt;&lt; <span class="hljs-string">&quot; @&quot;</span> &lt;&lt; tmp.h.c &lt;&lt; endl; <span class="hljs-comment">// Huge Mem from GetTemp @0x432139​</span><br>    ​​​​​​​​ <span class="hljs-keyword">return</span> tmp;​<br>&#125;<br><br>​<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ​<span class="hljs-function">Moveable <span class="hljs-title">a</span><span class="hljs-params">(GetTemp())</span></span>;<br>    ​cout &lt;&lt; hex &lt;&lt; <span class="hljs-string">&quot;Huge Mem from &quot;</span> &lt;&lt; **func * *​ &lt;&lt; <span class="hljs-string">&quot; @&quot;</span> &lt;&lt; a.h.c &lt;&lt; endl; <span class="hljs-comment">// Huge Mem from main @0x432139​</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义类型 HugeMem 和 Moveable，其中 Moveable 包含一个 HugeMem 成员变量,在 Moveable 的移动构造函数中使用 std::move 函数将 m.h 强制转化为右值，以便 Moveable 中的 h 能够实现移动构造，这里使用 std::move 是因为 m.h 是 m 的成员，m 将在表达式结束后被析构，其成员也会被析构<br>std::move 一般用于转化包含堆内存、文件句柄的实例为右值结合移动语义使用，并且被转化的实例在转化后不再使用，另外实现移动语义一定要自定义移动构造函数，编译器默认生成的移动构造函数和拷贝构造函数一样，都是按位拷贝的</p>
<h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><p>完美转发是指函数模板中完成按照模板的参数传递给真实调用的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IrunCodeActually</span><span class="hljs-params">(<span class="hljs-type">int</span> t)</span></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IamForwarding</span><span class="hljs-params">(cosnt T&amp; t)</span></span>&#123; <span class="hljs-built_in">IrunCodeActually</span>(t)&#125;<br></code></pre></td></tr></table></figure>

<p>转发函数使用 const T&amp;常量左值类型可以接收任意值，但是真实执行函数来说就没法接受(定义重载函数)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IrunCodeActually</span><span class="hljs-params">(<span class="hljs-type">int</span> t)</span></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IamForwarding</span><span class="hljs-params">(cosnt T&amp; t)</span></span>&#123; <span class="hljs-built_in">IrunCodeActually</span>(t)&#125;<br><span class="hljs-comment">// 重载函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IamForwarding</span><span class="hljs-params">(T t)</span></span>&#123; <span class="hljs-built_in">IrunCodeActually</span>(t)&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> T;<br><span class="hljs-keyword">typedef</span> T&amp; TR;<br>TR&amp; v = <span class="hljs-number">1</span>; <span class="hljs-comment">// c++11之前编译错误</span><br></code></pre></td></tr></table></figure>

<p>C++11 之前编译认为 TR&amp; v &#x3D; 1 是不合法的表达式，而 c++11 中发生应用折叠，即将复杂的未知表达式折叠为已知的简单表达式<br>C++11 引用折叠规则</p>
<table>
<thead>
<tr>
<th>TR 类型定义</th>
<th>声明 v 的类型</th>
<th>v 的实际类型</th>
</tr>
</thead>
<tbody><tr>
<td>T&amp;</td>
<td>TR</td>
<td>A&amp;</td>
</tr>
<tr>
<td>T&amp;</td>
<td>TR&amp;</td>
<td>A&amp;</td>
</tr>
<tr>
<td>T&amp;</td>
<td>TR&amp;&amp;</td>
<td>A&amp;</td>
</tr>
<tr>
<td>T&amp;&amp;</td>
<td>TR</td>
<td>A&amp;&amp;</td>
</tr>
<tr>
<td>T&amp;&amp;</td>
<td>TR&amp;</td>
<td>A&amp;</td>
</tr>
<tr>
<td>T&amp;&amp;</td>
<td>T&amp;&amp;</td>
<td>A&amp;&amp;</td>
</tr>
</tbody></table>
<p>结合引用折叠规则，上述示例类型折叠后 TR&amp; &#x3D;&#x3D; const int&amp;<br>C++11 中使用 std::forward 实现完美转发</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RunCode</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;&amp;m)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;rvalue ref&quot;</span> &lt;&lt; endl; &#125;<br>​​​​​​​​<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RunCode</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;m)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;lvalue ref&quot;</span> &lt;&lt; endl; &#125;<br>​​​​​​​​<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RunCode</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;&amp;m)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;const rvalue ref&quot;</span> &lt;&lt; endl; &#125;<br>​​​​​​​​<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RunCode</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;m)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;const lvalue ref&quot;</span> &lt;&lt; endl; &#125;<br>​​​​​​​​<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;￼​​​​​​​​<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PerfectForward</span><span class="hljs-params">(T &amp;&amp;t)</span> </span>&#123; <span class="hljs-built_in">RunCode</span>(forward&lt;T&gt;(t)); &#125;<br><br>​​​​​​​​<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   ​​​​​​​ <span class="hljs-type">int</span> a;<br>    ​​​​​​​​<span class="hljs-type">int</span> b;<br>    ​​​​​​​<span class="hljs-type">const</span> <span class="hljs-type">int</span> c = <span class="hljs-number">1</span>;<br>   ￼​<span class="hljs-type">const</span> <span class="hljs-type">int</span> d = <span class="hljs-number">0</span>;<br>    ​​​​​​​<span class="hljs-built_in">PerfectForward</span>(a); <span class="hljs-comment">// lvalue ref￼​​​​​​​​</span><br>    <span class="hljs-built_in">PerfectForward</span>(<span class="hljs-built_in">move</span>(b));                     <span class="hljs-comment">// rvalue ref￼​​​​​​​​</span><br>    <span class="hljs-built_in">PerfectForward</span>(c);                           <span class="hljs-comment">// const lvalue ref￼​​​​​​​​</span><br>    <span class="hljs-built_in">PerfectForward</span>(<span class="hljs-built_in">move</span>(d));                     <span class="hljs-comment">// const rvalue ref￼</span><br>​​​​​​​​&#125;<br></code></pre></td></tr></table></figure>

<h3 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h3><h4 id="语法定义"><a href="#语法定义" class="headerlink" title="语法定义"></a>语法定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">[capture](parameters) <span class="hljs-keyword">mutable</span> -&gt;<span class="hljs-keyword">return</span>-type &#123;<br>    statement<br>&#125;​​<br></code></pre></td></tr></table></figure>

<p>[capture]：捕捉列表，捕捉列表总是出现在 lambda 函数的开始处。事实上，[]是 lambda 引出符。编译器根据该引出符判断接下来的代码是否是 lambda 函数，捕捉列表能够捕捉上下文中的变量以供 lambda 函数使用</p>
<p>(parameters)：参数列表，与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号()一起省略</p>
<p>mutable：mutable 修饰符，默认情况下，lambda 函数总是一个 const 函数，mutable 可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）</p>
<p>-&gt;return-type：返回类型，用追踪返回类型形式声明函数的返回类型。出于方便，不需要返回值的时候也可以连同符号-&gt;一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导</p>
<p>{statement}：函数体，内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;￼​​​​​​​​​​<br>    []&#123;&#125;;                         <span class="hljs-comment">// 最简lambda函数￼​​​​​​​​</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;￼​​​​​​​​​​<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">4</span>;￼​​​​​​​​​​<br>    [=] &#123; <span class="hljs-keyword">return</span> a + b;&#125;;         <span class="hljs-comment">// 省略了参数列表与返回类型，返回类型由编译器推断为int￼​​​​​​​​</span><br>    <span class="hljs-keyword">auto</span> fun1 = [&amp;](<span class="hljs-type">int</span> c) &#123; b = a + c; &#125;;       <span class="hljs-comment">// 省略了返回类型，无返回值￼​​​​​​​</span><br>    <span class="hljs-keyword">auto</span> fun2 = [=, &amp;b](<span class="hljs-type">int</span> c)-&gt;<span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> b += a + c; &#125;;  <span class="hljs-comment">// 各部分都很完整的lambda函数￼​​​​​​</span><br>​&#125;￼<br></code></pre></td></tr></table></figure>

<p>语法上，捕捉列表由多个捕捉项组成,并以逗号分割,捕捉列表有如下几种形式：<br>[var]表示值传递方式捕捉变量 var<br>[&#x3D;]表示值传递方式捕捉所有父作用域的变量（包括 this）<br>[&amp;var]表示引用传递捕捉变量 var<br>[&amp;]表示引用传递捕捉所有父作用域的变量（包括 this）<br>[this]表示值传递方式捕捉当前的 this 指针</p>
<p>lambda 函数默认为 const 参数，值捕获的值仅可以读无法修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-keyword">auto</span> callback = [i]() <span class="hljs-comment">/*mutable*/</span> &#123;<br>       std::cout &lt;&lt; <span class="hljs-string">&quot;i: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;<br>       i = <span class="hljs-number">5</span>; <span class="hljs-comment">// 编译错误，lambda标识默认为const函数, 添加mutable可以更改值捕获的变量</span><br>       std::cout &lt;&lt; <span class="hljs-string">&quot;i: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;<br>   &#125;;<br><br>   <span class="hljs-built_in">callback</span>();<br><br>   std::cout &lt;&lt; <span class="hljs-string">&quot;i: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>[capture]捕获范围，C++11 中规定块作用域以外的捕获列表必须为空，父作用域中的自动变量可以捕获，但不能捕获静态变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">auto</span> callback = [i,j]() &#123; <span class="hljs-comment">// 编译错误</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;i: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;<br>    &#125;;<br><br>    <span class="hljs-built_in">callback</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;i: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="lambda-与仿函数"><a href="#lambda-与仿函数" class="headerlink" title="lambda 与仿函数"></a>lambda 与仿函数</h4><p>仿函数简单地说，就是重定义了成员函数 operator ()的一种自定义类型对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AirportPrice</span>&#123;￼<br>​​​​​​​​<span class="hljs-keyword">private</span>:￼​​​​​​​​    <br>    <span class="hljs-type">float</span> _dutyfreerate;<br>​​​​​​​​<span class="hljs-keyword">public</span>:￼​​​​​​​​    <br>    <span class="hljs-built_in">AirportPrice</span>(<span class="hljs-type">float</span> rate): _dutyfreerate(rate)&#123;&#125;￼​​​​​​​​    <br>    <span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">float</span> price)</span> </span>&#123;￼​​​​​​​​       <br>        <span class="hljs-keyword">return</span> price * (<span class="hljs-number">1</span>- _dutyfreerate/<span class="hljs-number">100</span>);￼​​​​​​​​    <br>    &#125;￼​​​’<br>​​​​​&#125;;￼<br><br>​​​​​​​​<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;￼​​​​​​​​    <br>    <span class="hljs-type">float</span> tax_rate = <span class="hljs-number">5.5f</span>;￼​​​​​​​​    <br>    <span class="hljs-function">AirportPrice <span class="hljs-title">Changi</span><span class="hljs-params">(tax_rate)</span></span>;￼​​​​​​​​   <br>    <span class="hljs-keyword">auto</span> Changi2 =￼​​​​​​​​[tax_rate](<span class="hljs-type">float</span> price)-&gt;<span class="hljs-type">float</span> &#123;<br>         <span class="hljs-keyword">return</span> price * (<span class="hljs-number">1</span>- tax_rate/<span class="hljs-number">100</span>); <br>    &#125;;   ￼​​​​​<br>    <span class="hljs-type">float</span> purchased = <span class="hljs-built_in">Changi</span>(<span class="hljs-number">3699</span>);￼​​​​​​​​    <br>    <span class="hljs-type">float</span> purchased2 = <span class="hljs-built_in">Changi2</span>(<span class="hljs-number">2899</span>);￼​​​​​​​​<br>&#125;￼<br></code></pre></td></tr></table></figure>
<p>该例中，分别使用了仿函数和lambda两种方式来完成扣税后的产品价格计算。在这里我们看到，lambda函数捕捉了tax_rate变量，而仿函数则以tax_rate初始化类</p>
<p>如在参数传递上，两者保持一致。可以看到，除去在语法层面上的不同，lambda和仿函数却有着相同的内涵—都可以捕捉一些变量作为初始状态，并接受参数进行运算。<br>而事实上，仿函数是编译器实现lambda的一种方式。在现阶段，通常编译器都会把lambda函数转化为成为一个仿函数对象。因此，在C++11中，lambda可以视为仿函数的一种等价形式了，或者更动听地说，lambda是仿函数的“语法糖”</p>
<h4 id="lambda易错点"><a href="#lambda易错点" class="headerlink" title="lambda易错点"></a>lambda易错点</h4><p>使用智能指针不当引发的资源泄露问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> OCallback = std::function&lt;<span class="hljs-built_in">void</span>()&gt;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Object</span>() = <span class="hljs-keyword">default</span>;<br>    ~<span class="hljs-built_in">Object</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;destory Object&quot;</span>&lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCallbackk</span><span class="hljs-params">(<span class="hljs-type">const</span> OCallback&amp; cb)</span> </span>&#123;<br>        m_cb = cb;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;excute something&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">if</span> (m_cb) &#123; <span class="hljs-built_in">m_cb</span>(); &#125;<br>    &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    OCallback m_cb;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> objPtr = std::<span class="hljs-built_in">make_shared</span>&lt;Object&gt;();<br>    <span class="hljs-keyword">auto</span> cb = [objPtr]() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;callback&quot;</span> &lt;&lt; std::endl;<br>    &#125;;<br>    objPtr-&gt;<span class="hljs-built_in">setCallbackk</span>(cb);<br>    objPtr-&gt;<span class="hljs-built_in">execute</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>解决方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> objPtr = std::<span class="hljs-built_in">make_shared</span>&lt;Object&gt;();<br>std::weak_ptr&lt;Object&gt; wself = objPtr;<br><span class="hljs-keyword">auto</span> cb = [wself]() &#123;<br>    <span class="hljs-keyword">auto</span> self = wself.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-keyword">if</span> (!self) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Object is destory&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;callback&quot;</span> &lt;&lt; std::endl;<br>&#125;;<br><br>objPtr-&gt;<span class="hljs-built_in">setCallbackk</span>(cb);<br>objPtr-&gt;<span class="hljs-built_in">execute</span>();<br></code></pre></td></tr></table></figure>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/" class="category-chain-item">编程技术</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/C/">#C++</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++11 特性学习笔记</div>
      <div>https://cronusl.github.io/2022/11/24/CPP11特性学习/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>cronus</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年11月24日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/11/11/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="正则表达式">
                        <span class="hidden-mobile">正则表达式</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'Cronusl/Cronusl.github.io');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
