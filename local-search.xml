<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++11 特性学习笔记</title>
    <link href="/2022/11/24/CPP11%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/11/24/CPP11%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="C-11-特性学习笔记"><a href="#C-11-特性学习笔记" class="headerlink" title="C++11 特性学习笔记"></a>C++11 特性学习笔记</h2><hr><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="1-nullptr"><a href="#1-nullptr" class="headerlink" title="1. nullptr"></a>1. nullptr</h4><p>指针空值：0-&gt; NULL -&gt; nullptr<br>典型的初始化指针将其执行空位置，比如 0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * ptr = <span class="number">0</span> / <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>NULL 示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    std:cout &lt;&lt; <span class="string">&quot;invoke f(int)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> *p)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;invoke f(char*)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">f</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">f</span>((<span class="type">char</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>NULL 在不同编译环境的定义&lt;stddef.h&gt;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined (_STDDEF_H) || defined (__need_NULL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> NULL<span class="comment">/* in case &lt;stdio.h&gt; has defined it. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__GNUG__) &amp;&amp; __GNUG__ &gt;= 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL __null</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>   <span class="comment">/* G++ */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>   <span class="comment">/* C++ */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _WIN64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0LL</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* W64 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* C++ */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* G++ */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">/* NULL not defined and &lt;stddef.h&gt; or need NULL.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>__need_NULL</span></span><br></pre></td></tr></table></figure><p>NULL 示例结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function">invoke <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function">2. 编译失败/<span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function">3. invoke <span class="title">f</span><span class="params">(<span class="type">char</span>*)</span></span></span><br></pre></td></tr></table></figure><p>C++11 提供 nullptr 关键字解决 NULL 带来的二义性问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(<span class="literal">nullptr</span>); <span class="comment">// invoke f(char*)</span></span><br></pre></td></tr></table></figure><p>空指针类型 nullptr_t<br>在 stddef.h 中定义 nullptr_t 类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GXX_NULLPTR_T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GXX_NULLPTR_T</span></span><br><span class="line">  <span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(<span class="literal">nullptr</span>)</span> <span class="type">nullptr_t</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* C++11.  */</span></span></span><br></pre></td></tr></table></figure><p>定义的 nullptr_t 实例与 nullptr 是等价的<br>nullptr_t npt;<br>npt &#x3D;&#x3D; nullptr; &#x2F;&#x2F; true<br>nullptr_t 类型在 C++11 标准下的约束：</p><ul><li>nullptr_t 类型数据可以转换为任意指针类型</li><li>nullptr_t 类型不能转化为非指针类型</li><li>nullptr_t 类型不适用于算数运算表达式</li><li>nullptr_t 类型仅适用于&#x3D;&#x3D;，&gt;&#x3D;, &lt;&#x3D;关系运算表达式时返回 true</li></ul><h4 id="2-auto"><a href="#2-auto" class="headerlink" title="2. auto"></a>2. auto</h4><p>auto 自动推导数据类型，可以简化初始化复杂类型变量的声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">1</span>; <span class="comment">// a -&gt; int</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">auto</span> b = <span class="built_in">f</span>(); <span class="comment">// b -&gt; double</span></span><br><span class="line">std::vector&lt;std::string&gt; vs;</span><br><span class="line"><span class="comment">// std::vector&lt;std::string&gt;::iterator begin = vs.begin();</span></span><br><span class="line"><span class="keyword">auto</span> begin = vs.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure><p>避免类型声明错误，C++中存着很多隐式或者用户自定义的类型转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PI</span> &#123;</span><br><span class="line">  <span class="type">double</span> <span class="keyword">operator</span>* (<span class="type">float</span> v) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)val * v;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">float</span> val = <span class="number">3.1415927f</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">float</span> radius = <span class="number">1.7e10</span>;</span><br><span class="line">  PI pi;</span><br><span class="line">  <span class="keyword">auto</span> circumference = <span class="number">2</span> * (pi * radius);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PI 内部设计避免数据上溢或者精度降低返回 double 类型数据，在 main 函数如果不小心使用 float 声明 circumference 就会破坏原本的设计，而使用 auto 可以编译器自动推导避免问题</p><p>auto 的在 C++11 标准中的约束：</p><ul><li>auto 不能用作函数形参类型</li><li>非静态成员变量的类型不能为 auto</li><li>auto 不能用于声明数组</li><li>auto 不能用于实例化模板时作为参数</li></ul><h4 id="3-decltype"><a href="#3-decltype" class="headerlink" title="3. decltype"></a>3. decltype</h4><p>decltype 用于类型推导, typeid 用于运行时获取变量的 type_info 信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) j = <span class="number">0</span>;</span><br><span class="line">std::count &lt;&lt; <span class="built_in">typeid</span>(j).<span class="built_in">name</span>() &lt;&lt; std::endl; <span class="comment">// int</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> a = <span class="number">1.0</span>;</span><br><span class="line"><span class="type">double</span> b = <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(a + b) c;</span><br><span class="line">std::count &lt;&lt; <span class="built_in">typeid</span>(c).<span class="built_in">name</span>() &lt;&lt; std::endl; <span class="comment">// double</span></span><br></pre></td></tr></table></figure><p>decltype 与 auto 有相同的作用，不过 decltype 更加灵活，可以用于推导表达式<br>结合 typedef 与 using 组合转化为符合具体含义的表达式提高代码的可读性和可维护性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; vs;</span><br><span class="line"><span class="keyword">using</span> VecType = <span class="keyword">decltype</span>(vs.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure><p>decltype 推导规则</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">decltype</span>(i) a;      <span class="comment">// init</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) b;    <span class="comment">// int&amp; 编译失败</span></span><br></pre></td></tr></table></figure><p>decltype(e)获取类型时编译器推导规则:</p><ul><li>如果 e 没有带括号的标记符表达式或者类成员时，e 就是所有命名实体的类型, 另外如果 e 为重载函数，则编译错误</li><li>否则，e 类型为 T, e 如果是一个将亡值，decltype(e)的类型为 T&amp;&amp;</li><li>否则，e 类型为 T，e 如果是一个左值，decltype(e)的类型为 T&amp;</li><li>否则，e 类型为 T，decltype(e)的类型为 T</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">4</span>;</span><br><span class="line">​​​​​​​​<span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">​​​​​​​​<span class="type">int</span> *ptr = arr;</span><br><span class="line">​​​​​​​​<span class="keyword">struct</span> <span class="title class_">S</span> &#123; <span class="type">double</span> d; &#125; s;</span><br><span class="line">​​​​​​​​<span class="function"><span class="type">void</span> <span class="title">Overloaded</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">​​​​​​​​<span class="function"><span class="type">void</span> <span class="title">Overloaded</span><span class="params">(<span class="type">char</span>)</span></span>;       <span class="comment">// 重载的函数</span></span><br><span class="line">​​​​​​​​<span class="function"><span class="type">int</span> &amp;&amp; <span class="title">RvalRef</span><span class="params">()</span></span>;</span><br><span class="line">​​​​​​​​<span class="function"><span class="type">const</span> <span class="type">bool</span> <span class="title">Func</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">​​​​​​​​<span class="comment">// 规则1: 单个标记符表达式以及访问类成员，推导为本类型</span></span><br><span class="line">​​​​​​​​<span class="keyword">decltype</span>(arr) var1;              <span class="comment">// int[5], 标记符表达式</span></span><br><span class="line">​​​​​​​​<span class="keyword">decltype</span>(ptr) var2;              <span class="comment">// int*, 标记符表达式</span></span><br><span class="line">​​​​​​​​<span class="keyword">decltype</span>(s.d) var4;              <span class="comment">// double, 成员访问表达式</span></span><br><span class="line">​​​​​​​​<span class="keyword">decltype</span>(Overloaded) var5;       <span class="comment">// 无法通过编译，是个重载的函数</span></span><br><span class="line"></span><br><span class="line">​​​​​​​​<span class="comment">// 规则2: 将亡值，推导为类型的右值引用</span></span><br><span class="line">​​​​​​​​<span class="keyword">decltype</span>(<span class="built_in">RvalRef</span>()) var6 = <span class="number">1</span>;   <span class="comment">// int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line">​​​​​​​​<span class="comment">// 规则3: 左值，推导为类型的引用</span></span><br><span class="line">​​​​​​​​<span class="keyword">decltype</span>(<span class="literal">true</span> ? i : i) var7 = i;       <span class="comment">// int&amp;, 三元运算符，这里返回一个i的左值</span></span><br><span class="line">​​​​​​​​<span class="keyword">decltype</span>((i)) var8 = i;                <span class="comment">// int&amp;, 带圆括号的左值</span></span><br><span class="line">​​​​​​​​<span class="keyword">decltype</span>(++i) var9 = i;                <span class="comment">// int&amp;, ++i返回i的左值</span></span><br><span class="line">​​​​​​​​<span class="keyword">decltype</span>(arr[<span class="number">3</span>]) var10 = i;            <span class="comment">// int&amp; []操作返回左值</span></span><br><span class="line">​​​​​​​​<span class="keyword">decltype</span>(*ptr)  var11 = i;             <span class="comment">// int&amp; *操作返回左值</span></span><br><span class="line">​​​​​​​​<span class="keyword">decltype</span>(<span class="string">&quot;hello&quot;</span>) var12 = <span class="string">&quot;hello&quot;</span>;       <span class="comment">// const char(&amp;)[6], 字符串字面常量为左值</span></span><br><span class="line"></span><br><span class="line">​​​​​​​​<span class="comment">// 规则4：以上都不是，推导为本类型</span></span><br><span class="line">​​​​​​​​<span class="keyword">decltype</span>(<span class="number">1</span>) var13;                 <span class="comment">// int, 除字符串外字面常量为右值</span></span><br><span class="line">​​​​​​​​<span class="keyword">decltype</span>(i++) var14;               <span class="comment">// int, i++返回右值</span></span><br><span class="line"><span class="keyword">decltype</span>((<span class="built_in">Func</span>(<span class="number">1</span>))) var15;         <span class="comment">// const bool, 圆括号可以忽略</span></span><br></pre></td></tr></table></figure><h4 id="4-using"><a href="#4-using" class="headerlink" title="4. using"></a>4. using</h4><p>C++11 之前一般用于引用命名空间<br>using namespace std;</p><p>C++11 可以用于定义数据类型别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> EASCalendarPtr = std::shared_ptr&lt;EASCalendar&gt;;</span><br><span class="line"></span><br><span class="line">常规使用<span class="keyword">typedef</span>定义数据类型别名</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> MyInt;</span><br><span class="line"><span class="keyword">using</span> MyInt = <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line">使用<span class="keyword">using</span>定义数据类型别名更加灵活</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> CustomMap = std::Map&lt;T, std::string&gt;;</span><br><span class="line"></span><br><span class="line">CustomMap&lt;<span class="type">int</span>&gt; numberCustomMap;</span><br><span class="line">CustomMap&lt;std::string&gt; stringCustomMap;</span><br></pre></td></tr></table></figure><p>C++11 使用 using 实现继承构造函数<br>通常情况下派生类可以自动获取基类定义的 public 虚函数和纯虚函数，对于构造函数也不例外，派生类如果需要使用基类的构造函数需要显示声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> i): <span class="built_in">A</span>(i)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一旦基类再定义其他的构造函数，派生类如果需要使用就需要显示定义并透传基类的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i)&#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i, <span class="type">double</span> j)&#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> std::string&amp; s)&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> i): <span class="built_in">A</span>(i)&#123;&#125;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> i, <span class="type">double</span> j):<span class="built_in">A</span>(i,j)&#123;&#125;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">const</span> std::string&amp;s):<span class="built_in">A</span>(s)&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 C++11 中可以使用 using 来声明继承基类的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A  &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> A:A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++11 标准继承构造函数被设计为跟派生类中的各种类默认函数（默认构造、析构、拷贝构造等）一样，是隐式声明的。这意味着如果一个继承构造函数不被相关代码使用，编译器不会为其产生真正的函数代码,这无疑比“透传”方案总是生成派生类的各种构造函数更加节省目标代码空间</p><p>如果继承的基类构造函数无法满足派生类的需求，可以通过再实现一个构造函数或者通过成员变量初始化的方式处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A  &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> A::A;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 自定义构造函数</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A  &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> A:A;</span><br><span class="line">    <span class="built_in">int</span>(<span class="type">int</span> i, <span class="type">int</span> d): <span class="built_in">A</span>(i), <span class="built_in">m_d</span>(d) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_d;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 成员变量初始化</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A  &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> A::A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_d = <span class="number">0</span>;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>多重继承出现继承冲突，通过显示定义继承类中冲突的构造函数处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="keyword">public</span>: <span class="built_in">A</span>(<span class="type">int</span>)&#123;&#125;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123; <span class="keyword">public</span>: <span class="built_in">A</span>(<span class="type">int</span>)&#123;&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> A::A;</span><br><span class="line">  <span class="keyword">using</span> B::B;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">C</span>(<span class="type">int</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-default"><a href="#5-default" class="headerlink" title="5. default"></a>5. default</h4><p>C++中自定义类的构造函数后编译器不再自动生成默认构造函数，使用 default 生成默认构造函数，<br>C++11 标准用&#x3D;default 修饰的函数为显示缺省函数,default 可以在类中定义修饰函数，也可以在定义之外修饰函数，这样可以在不同的实现文件中实现构造函数，从而可以切换不同的实现版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DefaultClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">DefaultClass</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  DefaultClass&amp; <span class="keyword">operator</span> = (<span class="type">const</span> DefaultClass&amp; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DefaultClass&amp; DefaultClass::<span class="keyword">operator</span> = (<span class="type">const</span> DefaultClass&amp;) = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure><h4 id="6-delete"><a href="#6-delete" class="headerlink" title="6. delete"></a>6. delete</h4><p>C++11 标准用&#x3D;delete 修饰的函数为显示删除函数，删除的函数明确禁止类型实例调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">禁止类实例拷贝，C++<span class="number">11</span>之前通过<span class="keyword">private</span>实现，C++<span class="number">11</span>可以通过<span class="keyword">delete</span>实现</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoCopy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">NoCopy</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">NoCopy</span>(<span class="type">const</span> NoCopy&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  NoCopy&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NoCopy&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">NoCopy</span>(NoCopy&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  NoCopy&amp; <span class="keyword">operator</span>=(NoCopy&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>显示删除自定义类型的 operator new 操作符禁止在堆上分配该类型的对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoHeapAlloc</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(std::<span class="type">size_t</span>)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  NoHeapAlloc nha;   <span class="comment">// 栈变量正常分配</span></span><br><span class="line">  NoHeapAlloc *pnha;  <span class="comment">// 编译失败，调用已删除的函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示删除析构函数限制自定义类型在栈上或者静态构造</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span>* p;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoStackAlloc</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ~<span class="built_in">NoStackAlloc</span>() = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">sizeof</span>(NoStackAlloc) + <span class="built_in">sizeof</span>(<span class="type">int</span>)];</span><br><span class="line"></span><br><span class="line">  NoStackAlloc nsa;  <span class="comment">// 编译失败</span></span><br><span class="line">  <span class="keyword">new</span> (p) <span class="built_in">NoStackAlloc</span>();<span class="comment">// placement new, 仅调用构造函数生成对象，非常规构建单实例</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-constexpr"><a href="#7-constexpr" class="headerlink" title="7. constexpr"></a>7. constexpr</h4><p>常量表达式是指值不会改变并且在编译过程中就能得到计算结果的表达式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;    <span class="comment">// 是常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = a + <span class="number">1</span>; <span class="comment">// 是常量表达式</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">11</span>;  <span class="comment">// 非常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> d = <span class="built_in">getValue</span>(); <span class="comment">// 非常量表达式</span></span><br></pre></td></tr></table></figure><p>C++11 之前如果是在比较复杂的系统中几乎不能分辨一个初始值到底是不是常量表达式，C++11 提供了 constexpr 关键字以便编译器在编译时验证变量是否是常量表达式，使用 constexpr 声明的变量一定是一个常量，而且必须用常量表达式初始化:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> b = a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> c = <span class="built_in">getValue</span>(); <span class="comment">// 只有当getValue()是一个constexpr函数编译才会成功</span></span><br></pre></td></tr></table></figure><p>指针与 constexpr<br>如果使用 constexpr 声明一个指针，则 constexpr 仅对指针有效，与指针所有指的对象无关：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = <span class="literal">nullptr</span>;        <span class="comment">// p是指向整型常量的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *q = <span class="literal">nullptr</span>;    <span class="comment">// q是指向整数的常量指针</span></span><br></pre></td></tr></table></figure><h4 id="8-final"><a href="#8-final" class="headerlink" title="8. final"></a>8. final</h4><p>通常情况下，基类中的 public 虚函数能够被派生类重载，有时候可能并不想要被重载，在 C+11 之前是不能限制的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> voif <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>: <span class="keyword">public</span> Object &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Drived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;  <span class="comment">// 编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>final 同样的对于类的继承也有相同的效果，如果确定某个类不允许再被继承，在类的声明中添加 final</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">XXXManager</span> <span class="keyword">final</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译错误</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DrivedManager</span>: <span class="keyword">public</span> XXXManager &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="9-override"><a href="#9-override" class="headerlink" title="9. override"></a>9. override</h4><p>C++11 中引用 override 关键字帮助程序员写继承结构复杂的类型，引入了虚函数描述符 override,如果派生类在虚函数声明时使用了 override，那么该函数必须重载基类中的同名函数，否则编译时无法通过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">​​​​​​​​​​<span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">​​​​​​​​    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Turing</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">​​​​​​​​    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">​​​​​​​​    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">VNeumann</span><span class="params">(<span class="type">int</span> g)</span> </span>= <span class="number">0</span>;</span><br><span class="line">​​​​​​​​    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DKnuth</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">​​​​​​​​    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line">​​​​​​​​&#125;;</span><br><span class="line"></span><br><span class="line">​​​​​​​​<span class="keyword">struct</span> <span class="title class_">DerivedMid</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">​​​​​​​​    <span class="comment">// void VNeumann(double g);</span></span><br><span class="line">​​​​​​​​    <span class="comment">// 新增一个VNeumann函数版本</span></span><br><span class="line">​​​​​​​​&#125;;</span><br><span class="line"></span><br><span class="line">​​​​​​​​<span class="keyword">struct</span> <span class="title class_">DerivedTop</span> : <span class="keyword">public</span> DerivedMid &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Turing</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">​​​​​​​​    <span class="function"><span class="type">void</span> <span class="title">Dikjstra</span><span class="params">()</span> <span class="keyword">override</span></span>;              <span class="comment">// 无法通过编译，拼写错误，并非重载</span></span><br><span class="line">​​​​​​​​    <span class="function"><span class="type">void</span> <span class="title">VNeumann</span><span class="params">(<span class="type">double</span> g)</span> <span class="keyword">override</span></span>;      <span class="comment">// 无法通过编译，参数不一致，并非重载</span></span><br><span class="line">​​​​​​​​    <span class="function"><span class="type">void</span> <span class="title">DKnuth</span><span class="params">()</span> <span class="keyword">override</span></span>;                <span class="comment">// 无法通过编译，常量性不一致，并非重载</span></span><br><span class="line">​​​​​​​​    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="keyword">override</span></span>;                 <span class="comment">// 无法通过编译，非虚函数重载</span></span><br><span class="line">​​​​​​​​&#125;;</span><br></pre></td></tr></table></figure><h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>C++类中包含指针成员，在使用拷贝构造时很容易出现内存泄露问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtrMem</span> &#123;</span><br><span class="line">​​​​​​​​<span class="keyword">public</span>:</span><br><span class="line">​​​​​​​​    <span class="built_in">HasPtrMem</span>(): <span class="built_in">d</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>)) &#123;&#125;</span><br><span class="line">​​​​​​​​    <span class="built_in">HasPtrMem</span>(<span class="type">const</span> HasPtrMem &amp; h):</span><br><span class="line">​​​​​​​​        <span class="built_in">d</span>(h.d) &#123;&#125;</span><br><span class="line">​​​​​​​​    ～<span class="built_in">HasPtrMem</span>() &#123; <span class="keyword">delete</span> d; &#125;</span><br><span class="line">​​​​​​​​    <span class="type">int</span> * d;</span><br><span class="line">​​​​​​​​&#125;;</span><br><span class="line">​​​​​​​​<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">​​​​​​​​    HasPtrMem a;</span><br><span class="line">​​​​​​​​    <span class="function">HasPtrMem <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">​​​​​​​​    cout &lt;&lt; *a.d &lt;&lt; endl;    <span class="comment">// 0</span></span><br><span class="line">​​​​​​​​    cout &lt;&lt; *b.d &lt;&lt; endl;    <span class="comment">// 0</span></span><br><span class="line">​​​​​​​​&#125;    <span class="comment">// 正常析构</span></span><br></pre></td></tr></table></figure><p>在函数中 b 实例是调用拷贝构造函数创建，拷贝构造函数作用类似于 memcpy 按位拷贝，这种就构造了 a.d 和 b.d 都指向同一块内存区域，当 main 函数作用域结束后，a 和 b 的析构函数被调用，当 b 析构后，a 中的成员 d 指针就成了悬挂指针，再调用析构函数时出现内存重复释放问题，这样的拷贝构造也就是浅拷贝，通常的处理方法是通过深拷贝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">HasPtrMem</span>(<span class="type">const</span> HasPtrMem &amp; h):</span><br><span class="line">​​​​​​​​        <span class="built_in">d</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*h.d)) &#123;&#125;</span><br></pre></td></tr></table></figure><p>深拷贝虽然能解决此类问题，但同样也带来性能问题，如果当成员 d 不是简单的 int 指针，而是占用内存比较大的类型指针，通过深拷贝的方式势必造成内存冗余问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtrMem</span> &#123;</span><br><span class="line">​​​​​​​​<span class="keyword">public</span>:</span><br><span class="line">​​​​​​​​    <span class="built_in">HasPtrMem</span>(): <span class="built_in">d</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">​​​​​​​​        cout &lt;&lt; <span class="string">&quot;Construct: &quot;</span> &lt;&lt; ++n_cstr &lt;&lt; endl;</span><br><span class="line">​​​​​​​​    &#125;</span><br><span class="line">​​​​​​​​    <span class="built_in">HasPtrMem</span>(<span class="type">const</span> HasPtrMem &amp; h): <span class="built_in">d</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*h.d)) &#123;</span><br><span class="line">​​​​​​​​        cout &lt;&lt; <span class="string">&quot;Copy construct: &quot;</span> &lt;&lt; ++n_cptr &lt;&lt; endl;</span><br><span class="line">​​​​​​​​    &#125;</span><br><span class="line">​​​​​​​​    ～<span class="built_in">HasPtrMem</span>() &#123;</span><br><span class="line">​​​​​​​​        cout &lt;&lt; <span class="string">&quot;Destruct: &quot;</span> &lt;&lt; ++n_dstr &lt;&lt; endl;</span><br><span class="line">​​​​​​​​    &#125;</span><br><span class="line">​​​​​​​​    <span class="type">int</span> * d;</span><br><span class="line">​​​​​​​​    <span class="type">static</span> <span class="type">int</span> n_cstr;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> n_dstr;</span><br><span class="line">​​​​​​​​    <span class="type">static</span> <span class="type">int</span> n_cptr;</span><br><span class="line">​​​​​​​​&#125;;</span><br><span class="line">​​​​​​​​<span class="type">int</span> HasPtrMem::n_cstr = <span class="number">0</span>;</span><br><span class="line">​​​​​​​​<span class="type">int</span> HasPtrMem::n_dstr = <span class="number">0</span>;</span><br><span class="line">​​​​​​​​<span class="type">int</span> HasPtrMem::n_cptr = <span class="number">0</span>;</span><br><span class="line">​​​​​​​​<span class="function">HasPtrMem <span class="title">GetTemp</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">HasPtrMem</span>(); &#125;</span><br><span class="line">​​​​​​​​<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">​​​​​​​​    HasPtrMem a = <span class="built_in">GetTemp</span>();</span><br><span class="line">​​​​​​​​&#125;</span><br></pre></td></tr></table></figure><p>示例代码构造函数、拷贝构造函数、析构函数分别调用多少次？</p><details><summary>结果</summary><p>Construct: 1<br>​​​​​​​​Copy construct: 1<br>​​​​​​​​Destruct: 1<br>​​​​​​​​Copy construct: 2<br>​​​​​​​​Destruct: 2<br>​​​​​​​​Destruct: 3​​</p><p>这里构造函数被调用了一次，这是在 GetTemp 函数中 HasPtrMem()表达式显式地调用了构造函数而打印出来的。而拷贝构造函数则被调用了两次。这两次一次是从 GetTemp 函数中 HasPtrMem()生成的变量上拷贝构造出一个临时值，以用作 GetTemp 的返回值，而另外一次则是由临时值构造出 main 中变量 a 调用的。对应地，析构函数也就调用了 3 次</p></details><p><strong>注意</strong> ： 编译器可能有优化移除了多余的构造函数调用，使用-fno-elide-constructors 编译选项禁止优化可以打印构造函数调用过程</p><p>这样的过程调用确实比较浪费资源，C++11 中可以通过移动构造函数来‘窃取’临时变量中的资源，这个过程成为移动语义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtrMem</span> &#123;</span><br><span class="line">​​​​​​​​<span class="keyword">public</span>:</span><br><span class="line">​​​​​​​​    <span class="built_in">HasPtrMem</span>(): <span class="built_in">d</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>)) &#123;</span><br><span class="line">​​​​​​​​        cout &lt;&lt; <span class="string">&quot;Construct: &quot;</span> &lt;&lt; ++n_cstr &lt;&lt; endl;</span><br><span class="line">​​​​​​​​    &#125;</span><br><span class="line">​​​​​​​​    <span class="built_in">HasPtrMem</span>(<span class="type">const</span> HasPtrMem &amp; h): <span class="built_in">d</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*h.d)) &#123;</span><br><span class="line">​​​​​​​​        cout &lt;&lt; <span class="string">&quot;Copy construct: &quot;</span> &lt;&lt; ++n_cptr &lt;&lt; endl;</span><br><span class="line">​​​​​​​​    &#125;</span><br><span class="line">​​​​​​​​    <span class="built_in">HasPtrMem</span>(HasPtrMem &amp;&amp; h): <span class="built_in">d</span>(h.d) &#123; <span class="comment">// 移动构造函数</span></span><br><span class="line">​​​​​​​​        h.d = <span class="literal">nullptr</span>;                      <span class="comment">// 将临时值的指针成员置空</span></span><br><span class="line">​​​​​​​​        cout &lt;&lt; <span class="string">&quot;Move construct: &quot;</span> &lt;&lt; ++n_mvtr &lt;&lt; endl;</span><br><span class="line">​​​​​​​​    &#125;</span><br><span class="line">​​​​​​​​      ～<span class="built_in">HasPtrMem</span>() &#123;</span><br><span class="line">​​​​​​​​          <span class="keyword">delete</span> d;</span><br><span class="line">​​​​​​​​          cout &lt;&lt; <span class="string">&quot;Destruct: &quot;</span> &lt;&lt; ++n_dstr &lt;&lt; endl;</span><br><span class="line">​​​​​​​​      &#125;</span><br><span class="line">​​​​​​​​      <span class="type">int</span> * d;</span><br><span class="line">​​​​​​​​      <span class="type">static</span> <span class="type">int</span> n_cstr;</span><br><span class="line">​​​​​​​​      <span class="type">static</span> <span class="type">int</span> n_dstr;</span><br><span class="line">​​​​​​​​      <span class="type">static</span> <span class="type">int</span> n_cptr;</span><br><span class="line">​​​​​​​​      <span class="type">static</span> <span class="type">int</span> n_mvtr;</span><br><span class="line">​​​​​​​​  &#125;;</span><br><span class="line">​​​​​​​​  <span class="type">int</span> HasPtrMem::n_cstr = <span class="number">0</span>;</span><br><span class="line">​​​​​​​​  <span class="type">int</span> HasPtrMem::n_dstr = <span class="number">0</span>;</span><br><span class="line">​​​​​​​​  <span class="type">int</span> HasPtrMem::n_cptr = <span class="number">0</span>;</span><br><span class="line">​​​​​​​​  <span class="type">int</span> HasPtrMem::n_mvtr = <span class="number">0</span>;</span><br><span class="line">​​​​​​​​  <span class="function">HasPtrMem <span class="title">GetTemp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">​​​​​​​​      HasPtrMem h;</span><br><span class="line">​​​​​​​​      cout &lt;&lt; <span class="string">&quot;Resource from &quot;</span> &lt;&lt;   __func__ &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; hex &lt;&lt; h.d &lt;&lt; endl;</span><br><span class="line">​​​​​​​​      <span class="keyword">return</span> h;</span><br><span class="line">​​​​​​​​  &#125;</span><br><span class="line"></span><br><span class="line">​​​​​​​​  <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">​​​​​​​​  HasPtrMem a = <span class="built_in">GetTemp</span>();</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Resource from &quot;</span> &lt;&lt;   __func__ &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; hex &lt;&lt; a.d &lt;&lt; endl;</span><br><span class="line">​​​​​​​​ &#125;</span><br></pre></td></tr></table></figure><p>调用结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Construct: 1​​</span><br><span class="line">​​​​​​​​​​Resource from GetTemp: 0x823010</span><br><span class="line">​​​​​​​​Move construct: 1</span><br><span class="line">Destruct: 1</span><br><span class="line">​​​​​​​​Move construct: 2​​​​​​​</span><br><span class="line">​Destruct: 2</span><br><span class="line">​​​​​​​​Resource from main: 0x823010</span><br><span class="line">Destruct: 3​​</span><br></pre></td></tr></table></figure><p>可以看到，这里没有调用拷贝构造函数，而是调用了两次移动构造函数，移动构造的结果是，GetTemp 中的 h 的指针成员 h.d 和 main 函数中的 a 的指针成员 a.d 的值是相同的，即 h.d 和 a.d 都指向了相同的堆地址内存。该堆内存在函数返回的过程中，不会调用析构函数释放，取而代之地，成为了赋值表达式中的变量 a 的资源</p><p>移动构造函数怎么触发的呢？</p><details>通过上述代码分析是返回了HasPtrMem的临时对象触发移动构造函数</details><p>左值、右值与右值引用<br>左值与右值是如何区分的呢？ 一个不严谨的区分方式是通过在赋值表达式中通过判断出现在&#x3D;左边的称为左值，而在右边的值称为右值</p><p>不过在 C++中一个被广泛认同的说法是，可以取地址并且有名字的是左值，不能取地址以及没有名字就是右值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> c = a + b;</span><br><span class="line"><span class="comment">// c是左值，(a+b)是右值</span></span><br></pre></td></tr></table></figure><p>C++11 右值由将亡值和纯右值构成<br>将亡值：与右值引用相关的表达式，比如返回右值引用的 T&amp;&amp;的函数返回值，std::move 返回值等<br>纯右值：非引用返回值函数返回的临时变量，运算表达式返回临时值，不跟对象关联的字面量值</p><p>在 C++中右值引用就是对一个右值进行引用的类型，实际上，右值通常是不具备名字，也只能通过引用的方式来与之关联</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T&amp;&amp; a = <span class="built_in">ReturnRValue</span>();</span><br><span class="line"></span><br><span class="line">T b = <span class="built_in">ReturnRValue</span>();</span><br></pre></td></tr></table></figure><p>a 和 b 调用 ReturnRvalue()返回右值函数区别在，a 是右值引用类型能过减少一次对象的构造和析构，直接绑定临时变量，通常情况下右值引用不能绑定任何左值变量，否则编译无法通过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Copyable</span> &#123;</span><br><span class="line">​​​​​​​​      <span class="built_in">Copyable</span>() &#123;&#125;</span><br><span class="line">​​​​​​​​      <span class="built_in">Copyable</span>(<span class="type">const</span> Copyable &amp;o) &#123;</span><br><span class="line">​​​​​​​​          cout &lt;&lt; <span class="string">&quot;Copied&quot;</span> &lt;&lt; endl;</span><br><span class="line">​​​​​​​​      &#125;</span><br><span class="line">      <span class="built_in">Copyable</span>(Copyable &amp;&amp;o) &#123;</span><br><span class="line">​​​​​​​​          cout &lt;&lt; <span class="string">&quot;Move Copied&quot;</span> &lt;&lt; endl;</span><br><span class="line">​​​​​​​​      &#125;</span><br><span class="line">​​​​​​​​  &#125;;</span><br><span class="line">​​​​​​​​  <span class="function">Copyable <span class="title">ReturnRvalue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Copyable</span>(); &#125;</span><br><span class="line">​​​​​​​​  <span class="function"><span class="type">void</span> <span class="title">AcceptVal</span><span class="params">(Copyable)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AcceptRef</span><span class="params">(Copyable &amp;&amp;)</span> </span>&#123;&#125;</span><br><span class="line">​​​​​​​​  <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">​​​​​​​​      cout &lt;&lt; <span class="string">&quot;Pass by value: &quot;</span> &lt;&lt; endl;</span><br><span class="line">​​​​​​​​      <span class="built_in">AcceptVal</span>(<span class="built_in">ReturnRvalue</span>()); <span class="comment">// 临时值被拷贝传入</span></span><br><span class="line">​​​​​​​​      cout &lt;&lt; <span class="string">&quot;Pass by reference: &quot;</span> &lt;&lt; endl;</span><br><span class="line">​​​​​​​​      <span class="built_in">AcceptRef</span>(<span class="built_in">ReturnRvalue</span>()); <span class="comment">// 临时值被作为引用传递</span></span><br><span class="line">​​​​​​​​  &#125;</span><br></pre></td></tr></table></figure><details><summary>结果</summary><p>Pass by value:<br>Move Copied<br>Move Copied<br>Pass by reference:<br>Move Copied</p></details><p>如果去掉移动拷贝构造函数，结果会是怎样？</p><details><summary>结果</summary><p>Pass by value:<br>​​​​​​​​Copied<br>​​​​​​​​Copied<br>​​​​​​​​Pass by reference:<br>​​​​​​​​Copied​​</p></details><p>从结果可以得知 C++11 中在移动拷贝构造函数无法使用时可以通过拷贝构造函数来兜底，也是 C++中设计的巧妙之处，移动不成还可以拷贝</p><p>C++11 区分左右值模板函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::is_lvalue_reference</span><br><span class="line">std::is_rvalue_reference</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; std::is_rvalue_reference(std::string &amp;&amp;)::value &lt;&lt; std::endl; // 1</span><br></pre></td></tr></table></figure><h4 id="std-move-函数"><a href="#std-move-函数" class="headerlink" title="std::move 函数"></a>std::move 函数</h4><p>C++11 标准库<utility>提供 std::move 函数，其本身不会启动任何东西，而是将左值强制转化为右值，相当于 static_cast&lt;T&amp;&amp;&gt;(lvalue)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Moveable</span> &#123;</span><br><span class="line">​<span class="keyword">public</span>:￼​​​​​​​​</span><br><span class="line">    <span class="built_in">Moveable</span>():<span class="built_in">i</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>)) &#123;&#125;￼​​​​​​​​</span><br><span class="line">    ～<span class="built_in">Moveable</span>() &#123; <span class="keyword">delete</span> i; &#125;￼​​​​​​​​</span><br><span class="line">    <span class="built_in">Moveable</span>(<span class="type">const</span> Moveable &amp; m): <span class="built_in">i</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*m.i)) &#123; &#125;￼​​​​​​​​</span><br><span class="line">    <span class="built_in">Moveable</span>(Moveable &amp;&amp; m):<span class="built_in">i</span>(m.i) &#123;￼​​​​​​​​</span><br><span class="line">        m.i = <span class="literal">nullptr</span>;￼​​​​​​​​</span><br><span class="line">    &#125;￼​​​​​​​​</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* i;￼​​​​​​​</span><br><span class="line">&#125;;</span><br><span class="line">￼</span><br><span class="line">​​​​​​​​<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;￼​​​​​​​​</span><br><span class="line">    Moveable a;￼​​​​​​​​</span><br><span class="line">    <span class="function">Moveable <span class="title">c</span><span class="params">(move(a))</span></span>;     <span class="comment">// 调用移动构造函数￼​​​​​​​​</span></span><br><span class="line">    cout &lt;&lt; *a.i &lt;&lt; endl;    <span class="comment">// 运行时错误</span></span><br><span class="line">​​​​​​​&#125;￼</span><br></pre></td></tr></table></figure><p>左值 a 被 std::move 转为右值，实例化变量 c 时触发 Moveable 的移动构造函数，a.i 指针被置为 nullptr,取空指针的值触发运行时错误，从该示例中得知，调用 std::move 转化的实例并不会随这转化后立马释放，错误的使用 std::move 函数可能会导致发生严重的运行时错误</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HugeMem</span> &#123;</span><br><span class="line">    ​<span class="keyword">public</span> :​ <span class="built_in">HugeMem</span>(<span class="type">int</span> size) : <span class="built_in">sz</span>(size &gt; <span class="number">0</span> ? size : <span class="number">1</span>) &#123;</span><br><span class="line">        ​ c = <span class="keyword">new</span> <span class="type">int</span>[sz];      ​</span><br><span class="line">    &#125;</span><br><span class="line">    ​～ <span class="built_in">HugeMem</span>() &#123; <span class="keyword">delete</span>[] c; &#125;</span><br><span class="line">    ​<span class="built_in">HugeMem</span>(HugeMem &amp;&amp;hm) : <span class="built_in">sz</span>(hm.sz), <span class="built_in">c</span>(hm.c) &#123;</span><br><span class="line">        ​ hm.c = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ​ <span class="type">int</span> _ c;</span><br><span class="line">    ​ <span class="type">int</span> sz;​</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">​<span class="keyword">class</span> <span class="title class_">Moveable</span> &#123;</span><br><span class="line">    ​<span class="keyword">public</span> :​ <span class="built_in">Moveable</span>() : <span class="built_in">i</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>)), <span class="built_in">h</span>(<span class="number">1024</span>) &#123;&#125;</span><br><span class="line">    ​ ～ <span class="built_in">Moveable</span>() &#123; <span class="keyword">delete</span> i; &#125;</span><br><span class="line">    ​ <span class="built_in">Moveable</span>(Moveable &amp;&amp;m) :​ <span class="built_in">i</span>(m.i), <span class="built_in">h</span>(<span class="built_in">move</span>(m.h)) &#123; <span class="comment">// 强制转为右值，以调用移动构造函数 ​</span></span><br><span class="line">        m.i = <span class="literal">nullptr</span>;​</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ​int_ i;</span><br><span class="line">    ​HugeMem h;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">​<span class="function">Moveable <span class="title">GetTemp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ​ Moveable tmp = <span class="built_in">Moveable</span>();</span><br><span class="line">    ​ cout &lt;&lt; hex &lt;&lt; <span class="string">&quot;Huge Mem from &quot;</span> &lt;&lt; **func * *​ &lt;&lt; <span class="string">&quot; @&quot;</span> &lt;&lt; tmp.h.c &lt;&lt; endl; <span class="comment">// Huge Mem from GetTemp @0x432139​</span></span><br><span class="line">    ​​​​​​​​ <span class="keyword">return</span> tmp;​</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">​<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ​<span class="function">Moveable <span class="title">a</span><span class="params">(GetTemp())</span></span>;</span><br><span class="line">    ​cout &lt;&lt; hex &lt;&lt; <span class="string">&quot;Huge Mem from &quot;</span> &lt;&lt; **func * *​ &lt;&lt; <span class="string">&quot; @&quot;</span> &lt;&lt; a.h.c &lt;&lt; endl; <span class="comment">// Huge Mem from main @0x432139​</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义类型 HugeMem 和 Moveable，其中 Moveable 包含一个 HugeMem 成员变量,在 Moveable 的移动构造函数中使用 std::move 函数将 m.h 强制转化为右值，以便 Moveable 中的 h 能够实现移动构造，这里使用 std::move 是因为 m.h 是 m 的成员，m 将在表达式结束后被析构，其成员也会被析构<br>std::move 一般用于转化包含堆内存、文件句柄的实例为右值结合移动语义使用，并且被转化的实例在转化后不再使用，另外实现移动语义一定要自定义移动构造函数，编译器默认生成的移动构造函数和拷贝构造函数一样，都是按位拷贝的</p><h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><p>完美转发是指函数模板中完成按照模板的参数传递给真实调用的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">IrunCodeActually</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IamForwarding</span><span class="params">(cosnt T&amp; t)</span></span>&#123; <span class="built_in">IrunCodeActually</span>(t)&#125;</span><br></pre></td></tr></table></figure><p>转发函数使用 const T&amp;常量左值类型可以接收任意值，但是真实执行函数来说就没法接受(定义重载函数)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">IrunCodeActually</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IamForwarding</span><span class="params">(cosnt T&amp; t)</span></span>&#123; <span class="built_in">IrunCodeActually</span>(t)&#125;</span><br><span class="line"><span class="comment">// 重载函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IamForwarding</span><span class="params">(T t)</span></span>&#123; <span class="built_in">IrunCodeActually</span>(t)&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> <span class="type">int</span> T;</span><br><span class="line"><span class="keyword">typedef</span> T&amp; TR;</span><br><span class="line">TR&amp; v = <span class="number">1</span>; <span class="comment">// c++11之前编译错误</span></span><br></pre></td></tr></table></figure><p>C++11 之前编译认为 TR&amp; v &#x3D; 1 是不合法的表达式，而 c++11 中发生应用折叠，即将复杂的未知表达式折叠为已知的简单表达式<br>C++11 引用折叠规则</p><table><thead><tr><th>TR 类型定义</th><th>声明 v 的类型</th><th>v 的实际类型</th></tr></thead><tbody><tr><td>T&amp;</td><td>TR</td><td>A&amp;</td></tr><tr><td>T&amp;</td><td>TR&amp;</td><td>A&amp;</td></tr><tr><td>T&amp;</td><td>TR&amp;&amp;</td><td>A&amp;</td></tr><tr><td>T&amp;&amp;</td><td>TR</td><td>A&amp;&amp;</td></tr><tr><td>T&amp;&amp;</td><td>TR&amp;</td><td>A&amp;</td></tr><tr><td>T&amp;&amp;</td><td>T&amp;&amp;</td><td>A&amp;&amp;</td></tr></tbody></table><p>结合引用折叠规则，上述示例类型折叠后 TR&amp; &#x3D;&#x3D; const int&amp;<br>C++11 中使用 std::forward 实现完美转发</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunCode</span><span class="params">(<span class="type">int</span> &amp;&amp;m)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;rvalue ref&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">​​​​​​​​<span class="function"><span class="type">void</span> <span class="title">RunCode</span><span class="params">(<span class="type">int</span> &amp;m)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;lvalue ref&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">​​​​​​​​<span class="function"><span class="type">void</span> <span class="title">RunCode</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;&amp;m)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;const rvalue ref&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">​​​​​​​​<span class="function"><span class="type">void</span> <span class="title">RunCode</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;m)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;const lvalue ref&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">​​​​​​​​<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;￼​​​​​​​​<span class="function"><span class="type">void</span> <span class="title">PerfectForward</span><span class="params">(T &amp;&amp;t)</span> </span>&#123; <span class="built_in">RunCode</span>(forward&lt;T&gt;(t)); &#125;</span><br><span class="line"></span><br><span class="line">​​​​​​​​<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ​​​​​​​ <span class="type">int</span> a;</span><br><span class="line">    ​​​​​​​​<span class="type">int</span> b;</span><br><span class="line">    ​​​​​​​<span class="type">const</span> <span class="type">int</span> c = <span class="number">1</span>;</span><br><span class="line">   ￼​<span class="type">const</span> <span class="type">int</span> d = <span class="number">0</span>;</span><br><span class="line">    ​​​​​​​<span class="built_in">PerfectForward</span>(a); <span class="comment">// lvalue ref￼​​​​​​​​</span></span><br><span class="line">    <span class="built_in">PerfectForward</span>(<span class="built_in">move</span>(b));                     <span class="comment">// rvalue ref￼​​​​​​​​</span></span><br><span class="line">    <span class="built_in">PerfectForward</span>(c);                           <span class="comment">// const lvalue ref￼​​​​​​​​</span></span><br><span class="line">    <span class="built_in">PerfectForward</span>(<span class="built_in">move</span>(d));                     <span class="comment">// const rvalue ref￼</span></span><br><span class="line">​​​​​​​​&#125;</span><br></pre></td></tr></table></figure><h3 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h3><h4 id="语法定义"><a href="#语法定义" class="headerlink" title="语法定义"></a>语法定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters) <span class="keyword">mutable</span> -&gt;<span class="keyword">return</span>-type &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;​​</span><br></pre></td></tr></table></figure><p>[capture]：捕捉列表，捕捉列表总是出现在 lambda 函数的开始处。事实上，[]是 lambda 引出符。编译器根据该引出符判断接下来的代码是否是 lambda 函数，捕捉列表能够捕捉上下文中的变量以供 lambda 函数使用</p><p>(parameters)：参数列表，与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号()一起省略</p><p>mutable：mutable 修饰符，默认情况下，lambda 函数总是一个 const 函数，mutable 可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）</p><p>-&gt;return-type：返回类型，用追踪返回类型形式声明函数的返回类型。出于方便，不需要返回值的时候也可以连同符号-&gt;一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导</p><p>{statement}：函数体，内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;￼​​​​​​​​​​</span><br><span class="line">    []&#123;&#125;;                         <span class="comment">// 最简lambda函数￼​​​​​​​​</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>;￼​​​​​​​​​​</span><br><span class="line">    <span class="type">int</span> b = <span class="number">4</span>;￼​​​​​​​​​​</span><br><span class="line">    [=] &#123; <span class="keyword">return</span> a + b;&#125;;         <span class="comment">// 省略了参数列表与返回类型，返回类型由编译器推断为int￼​​​​​​​​</span></span><br><span class="line">    <span class="keyword">auto</span> fun1 = [&amp;](<span class="type">int</span> c) &#123; b = a + c; &#125;;       <span class="comment">// 省略了返回类型，无返回值￼​​​​​​​</span></span><br><span class="line">    <span class="keyword">auto</span> fun2 = [=, &amp;b](<span class="type">int</span> c)-&gt;<span class="type">int</span> &#123; <span class="keyword">return</span> b += a + c; &#125;;  <span class="comment">// 各部分都很完整的lambda函数￼​​​​​​</span></span><br><span class="line">​&#125;￼</span><br></pre></td></tr></table></figure><p>语法上，捕捉列表由多个捕捉项组成,并以逗号分割,捕捉列表有如下几种形式：<br>[var]表示值传递方式捕捉变量 var<br>[&#x3D;]表示值传递方式捕捉所有父作用域的变量（包括 this）<br>[&amp;var]表示引用传递捕捉变量 var<br>[&amp;]表示引用传递捕捉所有父作用域的变量（包括 this）<br>[this]表示值传递方式捕捉当前的 this 指针</p><p>lambda 函数默认为 const 参数，值捕获的值仅可以读无法修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">auto</span> callback = [i]() <span class="comment">/*mutable*/</span> &#123;</span><br><span class="line">       std::cout &lt;&lt; <span class="string">&quot;i: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">       i = <span class="number">5</span>; <span class="comment">// 编译错误，lambda标识默认为const函数, 添加mutable可以更改值捕获的变量</span></span><br><span class="line">       std::cout &lt;&lt; <span class="string">&quot;i: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">callback</span>();</span><br><span class="line"></span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;i: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[capture]捕获范围，C++11 中规定块作用域以外的捕获列表必须为空，父作用域中的自动变量可以捕获，但不能捕获静态变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> callback = [i,j]() &#123; <span class="comment">// 编译错误</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;i: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">callback</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;i: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lambda-与仿函数"><a href="#lambda-与仿函数" class="headerlink" title="lambda 与仿函数"></a>lambda 与仿函数</h4><p>仿函数简单地说，就是重定义了成员函数 operator ()的一种自定义类型对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AirportPrice</span>&#123;￼</span><br><span class="line">​​​​​​​​<span class="keyword">private</span>:￼​​​​​​​​    </span><br><span class="line">    <span class="type">float</span> _dutyfreerate;</span><br><span class="line">​​​​​​​​<span class="keyword">public</span>:￼​​​​​​​​    </span><br><span class="line">    <span class="built_in">AirportPrice</span>(<span class="type">float</span> rate): _dutyfreerate(rate)&#123;&#125;￼​​​​​​​​    </span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">float</span> price)</span> </span>&#123;￼​​​​​​​​       </span><br><span class="line">        <span class="keyword">return</span> price * (<span class="number">1</span>- _dutyfreerate/<span class="number">100</span>);￼​​​​​​​​    </span><br><span class="line">    &#125;￼​​​’</span><br><span class="line">​​​​​&#125;;￼</span><br><span class="line"></span><br><span class="line">​​​​​​​​<span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;￼​​​​​​​​    </span><br><span class="line">    <span class="type">float</span> tax_rate = <span class="number">5.5f</span>;￼​​​​​​​​    </span><br><span class="line">    <span class="function">AirportPrice <span class="title">Changi</span><span class="params">(tax_rate)</span></span>;￼​​​​​​​​   </span><br><span class="line">    <span class="keyword">auto</span> Changi2 =￼​​​​​​​​[tax_rate](<span class="type">float</span> price)-&gt;<span class="type">float</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> price * (<span class="number">1</span>- tax_rate/<span class="number">100</span>); </span><br><span class="line">    &#125;;   ￼​​​​​</span><br><span class="line">    <span class="type">float</span> purchased = <span class="built_in">Changi</span>(<span class="number">3699</span>);￼​​​​​​​​    </span><br><span class="line">    <span class="type">float</span> purchased2 = <span class="built_in">Changi2</span>(<span class="number">2899</span>);￼​​​​​​​​</span><br><span class="line">&#125;￼</span><br></pre></td></tr></table></figure><p>该例中，分别使用了仿函数和lambda两种方式来完成扣税后的产品价格计算。在这里我们看到，lambda函数捕捉了tax_rate变量，而仿函数则以tax_rate初始化类</p><p>如在参数传递上，两者保持一致。可以看到，除去在语法层面上的不同，lambda和仿函数却有着相同的内涵—都可以捕捉一些变量作为初始状态，并接受参数进行运算。<br>而事实上，仿函数是编译器实现lambda的一种方式。在现阶段，通常编译器都会把lambda函数转化为成为一个仿函数对象。因此，在C++11中，lambda可以视为仿函数的一种等价形式了，或者更动听地说，lambda是仿函数的“语法糖”</p><h4 id="lambda易错点"><a href="#lambda易错点" class="headerlink" title="lambda易错点"></a>lambda易错点</h4><p>使用智能指针不当引发的资源泄露问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> OCallback = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Object</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Object</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Object</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;destory Object&quot;</span>&lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCallbackk</span><span class="params">(<span class="type">const</span> OCallback&amp; cb)</span> </span>&#123;</span><br><span class="line">        m_cb = cb;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;excute something&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">if</span> (m_cb) &#123; <span class="built_in">m_cb</span>(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    OCallback m_cb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> objPtr = std::<span class="built_in">make_shared</span>&lt;Object&gt;();</span><br><span class="line">    <span class="keyword">auto</span> cb = [objPtr]() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;callback&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    objPtr-&gt;<span class="built_in">setCallbackk</span>(cb);</span><br><span class="line">    objPtr-&gt;<span class="built_in">execute</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> objPtr = std::<span class="built_in">make_shared</span>&lt;Object&gt;();</span><br><span class="line">std::weak_ptr&lt;Object&gt; wself = objPtr;</span><br><span class="line"><span class="keyword">auto</span> cb = [wself]() &#123;</span><br><span class="line">    <span class="keyword">auto</span> self = wself.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (!self) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Object is destory&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;callback&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">objPtr-&gt;<span class="built_in">setCallbackk</span>(cb);</span><br><span class="line">objPtr-&gt;<span class="built_in">execute</span>();</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2022/11/11/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2022/11/11/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><h4 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h4><p>&#x2F;[.*]&#x2F;</p><h4 id="非贪婪匹配"><a href="#非贪婪匹配" class="headerlink" title="非贪婪匹配"></a>非贪婪匹配</h4><p>&#x2F;[.*?]<br>通过在 *、+ 或 ? 限定符之后放置 ?，该表达式从”贪婪”表达式转换为”非贪婪”表达式或者最小匹配</p><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>圆括号()表示分组</p><h4 id="捕获元"><a href="#捕获元" class="headerlink" title="捕获元"></a>捕获元</h4><p>exp1(?&#x3D;exp2) 查找 exp2 前面的 exp1</p>]]></content>
    
    
    <categories>
      
      <category>编程技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqlite视图</title>
    <link href="/2019/01/21/sqlite3%E8%A7%86%E5%9B%BE/"/>
    <url>/2019/01/21/sqlite3%E8%A7%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="SQLite-视图"><a href="#SQLite-视图" class="headerlink" title="SQLite 视图"></a>SQLite 视图</h3><hr><h4 id="SQLite-视图-1"><a href="#SQLite-视图-1" class="headerlink" title="SQLite 视图"></a>SQLite 视图</h4><p>在数据库理论中，视图是存储查询的结果集。视图是将查询打包到命名对象的方法，可以通过视图访问基础表的数据。视图定义中的查询引用的表称为基表</p><blockquote><p><strong>视图的使用场景:</strong></p><ol><li>视图提供一个基于表的抽象层，你可以在视图中添加和删除列，而无需接触基础表的架构</li><li>你可以使用视图来封装带有连接的复杂查询，以简化数据访问</li></ol><p><strong>注意：</strong>视图是只读的，意味着你不可以在视图中使用INSERT，UPDATE和DELETE操作</p></blockquote><span id="more"></span><h4 id="SQLite-CREATE-VIEW-创建视图"><a href="#SQLite-CREATE-VIEW-创建视图" class="headerlink" title="SQLite CREATE VIEW 创建视图"></a>SQLite CREATE VIEW 创建视图</h4><p>创建视图的格式如下: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE [TEMP] VIEW [IF NOT EXISTS] view_name(column-name-list)</span><br><span class="line">AS </span><br><span class="line">   select-statement;</span><br></pre></td></tr></table></figure><ol><li>设置视图的名称，IF NOT EXISTS可选项可以防止重复创建视图</li><li>如果你想仅在数据连接的时候才想视图是可见的，可以使用TEMP或TEMPORARY可选项创建，当数据库被关闭时SQLite会自动清除临时的视图</li></ol><h4 id="SQLite-CREATE-VIEW-示例"><a href="#SQLite-CREATE-VIEW-示例" class="headerlink" title="SQLite CREATE VIEW 示例"></a>SQLite CREATE VIEW 示例</h4><p>假设需要从同一个数据库的tracks, albums和genres表中使用内连接获取数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line"> trackid,</span><br><span class="line"> tracks.name,</span><br><span class="line"> albums.Title AS album,</span><br><span class="line"> media_types.Name AS media,</span><br><span class="line"> genres.Name AS genres</span><br><span class="line">FROM</span><br><span class="line"> tracks</span><br><span class="line">INNER JOIN albums ON Albums.AlbumId = tracks.AlbumId</span><br><span class="line">INNER JOIN media_types ON media_types.MediaTypeId = tracks.MediaTypeId</span><br><span class="line">INNER JOIN genres ON genres.GenreId = tracks.GenreId;</span><br></pre></td></tr></table></figure><p><img src="http://www.sqlitetutorial.net/wp-content/uploads/2015/12/MySQL-CREATE-VIEW-example.jpg" alt="MySQL CREATE VIEW example"></p><p>基于这个查询可以创建如下视图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW v_tracks </span><br><span class="line">AS </span><br><span class="line">SELECT</span><br><span class="line"> trackid,</span><br><span class="line"> tracks.name,</span><br><span class="line"> albums.Title AS album,</span><br><span class="line"> media_types.Name AS media,</span><br><span class="line"> genres.Name AS genres</span><br><span class="line">FROM</span><br><span class="line"> tracks</span><br><span class="line">INNER JOIN albums ON Albums.AlbumId = tracks.AlbumId</span><br><span class="line">INNER JOIN media_types ON media_types.MediaTypeId = tracks.MediaTypeId</span><br><span class="line">INNER JOIN genres ON genres.GenreId = tracks.GenreId;</span><br></pre></td></tr></table></figure><p>现在可以使用如下简单的查询语句代替之前复杂的语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line"> *</span><br><span class="line">FROM</span><br><span class="line"> v_tracks</span><br></pre></td></tr></table></figure><h4 id="移除视图"><a href="#移除视图" class="headerlink" title="移除视图"></a>移除视图</h4><p>使用DROP VIEW移除视图，格式如下: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW [IF EXISTS] view_name;</span><br></pre></td></tr></table></figure><p>如果你移除一个不存在的视图，那么SQLite会发出一个错误，可以使用IF EXISTS可选项来防止，只有当要删除的视图存在的时候才会执行删除视图</p><p><strong>删除视图示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW v_tracks;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过视图的抽象层可以自由的添加和移除数据列，而不用接触基础表的架构，另外可以将负责的SQL查询语句封装在视图中，简化查询语句</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p> SQLite View</p><p> <a href="http://www.sqlitetutorial.net/sqlite-create-view/">http://www.sqlitetutorial.net/sqlite-create-view/</a></p>]]></content>
    
    
    <categories>
      
      <category>sqlite3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sqlite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqlite3触发器</title>
    <link href="/2019/01/21/sqlite3%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <url>/2019/01/21/sqlite3%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="SQLite-触发器"><a href="#SQLite-触发器" class="headerlink" title="SQLite 触发器"></a>SQLite 触发器</h3><hr><h4 id="SQLite触发器"><a href="#SQLite触发器" class="headerlink" title="SQLite触发器"></a>SQLite触发器</h4><p>sqlite触发器是一个命名的数据库对象，当在相关联的表执行<code>INSERT</code>,<code>UPDATE</code>,<code>DELETE</code>语句时自动执行</p><h4 id="SQLite-CREATE-TRIGGER-语句"><a href="#SQLite-CREATE-TRIGGER-语句" class="headerlink" title="SQLite  CREATE TRIGGER 语句"></a>SQLite  CREATE TRIGGER 语句</h4><p>创建一个触发器可以使用CREATE TRIGGER语句，格式如下</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER [IF NOT EXISTS] trigger_name </span><br><span class="line">   [BEFORE|AFTER|INSTEAD OF] [INSERT|UPDATE|DELETE] </span><br><span class="line">   ON table_name</span><br><span class="line">   [WHEN condition]</span><br><span class="line">BEGIN</span><br><span class="line"> statements;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><ol><li>在CREATE TRIGGER后设置触发器的名称</li><li>决定触发的时机，BEFORE 、AFTER或 INSTEAD OF 三种情况</li><li>指定触发器执行的事件，INSERT、UPDATE或DELETE 三种情况</li><li>指定触发器关联的表</li><li>指定触发器执行的条件(可选)</li><li>在BEGIN END块内放置触发器的逻辑，可以是任意合法的SQL语句</li></ol><p>如果触发时机和事件组合，总共有如下9中组合方式: </p><ul><li>BEFORE INSERT</li><li>AFTER INSERT</li><li>BEFORE UPDATE</li><li>AFTER UPDATE</li><li>BEFORE DELETE</li><li>AFTER DELETE</li><li>INSTEAD OF INSERT</li><li>INSTEAD OF DELETE</li><li>INSTEAD OF UPDATE</li></ul><p>假设你使用UPDATE语句更新了某张表的10条数据，跟表关联的触发器会执行10次，这种触发器被称为FOR EACH ROW触发器，如果关联的触发器只执行1次，这种触发器称为FOR EACH STATEMENT触发器</p><blockquote><p><strong>注意:</strong> 3.9.2版本的SQLite仅提供支持FOR EACH ROW triggers触发器</p></blockquote><p>如果使用WHEN设置条件，那么只有当条件为TRUE时才会执行触发器， 如果忽略掉WHEN时，那么触发器对所有行的数据都会执行</p><blockquote><p><strong>重要:</strong> 当删除(DROP TABLE)表时关联的触发器也会被删除</p></blockquote><p>另外可以使用OLD和NEW关键字来访问被插入、更新或删除的数据：OLD.column_name 和 NEW.column_name</p><p>NEW和OLD依赖导致触发器执行的事件, 关系如下: </p><table><thead><tr><th>Action</th><th>Reference</th></tr></thead><tbody><tr><td>INSERT</td><td>NEW 可用</td></tr><tr><td>UPDATE</td><td>NEW OLD 两者都可用</td></tr><tr><td>DELETE</td><td>OLD 可用</td></tr></tbody></table><h4 id="SQLite触发器示例"><a href="#SQLite触发器示例" class="headerlink" title="SQLite触发器示例"></a>SQLite触发器示例</h4><p>创建一张名为leads的表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE leads (</span><br><span class="line"> id integer PRIMARY KEY,</span><br><span class="line"> first_name text NOT NULL,</span><br><span class="line"> last_name text NOT NULL,</span><br><span class="line"> phone text NOT NULL,</span><br><span class="line"> email text NOT NULL,</span><br><span class="line"> source text NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="SQLite-BEFORE-INSERT触发器示例"><a href="#SQLite-BEFORE-INSERT触发器示例" class="headerlink" title="SQLite BEFORE INSERT触发器示例"></a>SQLite BEFORE INSERT触发器示例</h5><p>假设在leads表中插入数据前先检查邮箱地址的合法性，这种场景可以使用BEFORE INSERT触发器</p><p>创建BEFORE INSERT触发器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER validate_email_before_insert_leads BEFORE INSERT ON leads</span><br><span class="line">BEGIN</span><br><span class="line"> SELECT</span><br><span class="line"> CASE</span><br><span class="line"> WHEN NEW.email NOT LIKE &#x27;%_@__%.__%&#x27; THEN</span><br><span class="line"> RAISE (</span><br><span class="line"> ABORT,</span><br><span class="line"> &#x27;Invalid email address&#x27;</span><br><span class="line"> )</span><br><span class="line"> END;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>我们使用NEW关键字来访问要插入的email字段的数据，为了验证email的合法性，我们使用LIKE操作符来决定email是否匹配邮箱地址的格式，如果不合法，我们使用RAISE函数来中止插入操作并且提示错误信息</p><p>1）插入非法的email数据到leads表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO leads (</span><br><span class="line"> first_name,</span><br><span class="line"> last_name,</span><br><span class="line"> email,</span><br><span class="line"> phone</span><br><span class="line">)</span><br><span class="line">VALUES</span><br><span class="line"> (</span><br><span class="line"> &#x27;John&#x27;,</span><br><span class="line"> &#x27;Doe&#x27;,</span><br><span class="line"> &#x27;jjj&#x27;,</span><br><span class="line"> &#x27;4089009334&#x27;</span><br><span class="line"> );</span><br></pre></td></tr></table></figure><p>SQLite提示错误: Invalid email address并且中止插入数据操作</p><p>2）插入合法的Email数据库到leads表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO leads (</span><br><span class="line"> first_name,</span><br><span class="line"> last_name,</span><br><span class="line"> email,</span><br><span class="line"> phone</span><br><span class="line">)</span><br><span class="line">VALUES</span><br><span class="line"> (</span><br><span class="line"> &#x27;John&#x27;,</span><br><span class="line"> &#x27;Doe&#x27;,</span><br><span class="line"> &#x27;john.doe@sqlitetutorial.net&#x27;,</span><br><span class="line"> &#x27;4089009334&#x27;</span><br><span class="line"> );</span><br></pre></td></tr></table></figure><p>数据都是合法的，因此可以插入数据到leads表中成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line"> first_name,</span><br><span class="line"> last_name,</span><br><span class="line"> email,</span><br><span class="line"> phone</span><br><span class="line">FROM</span><br><span class="line"> leads;</span><br></pre></td></tr></table></figure><p> <img src="http://www.sqlitetutorial.net/wp-content/uploads/2015/12/SQLite-TRIGGER-Leads-Table.png" alt="div"> </p><h5 id="SQLite-AFTER-UPDATE-触发器"><a href="#SQLite-AFTER-UPDATE-触发器" class="headerlink" title="SQLite AFTER UPDATE 触发器"></a>SQLite AFTER UPDATE 触发器</h5><p>leader的电话和邮箱都是很重要的信息并且这些信息不能丢失，这种场景下为了防止用户误操作导致数据修改错误或者丢失，可以使用触发器记录所有修改的记录</p><p>创建lead_logs表用于存储所有修改的记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE lead_logs (</span><br><span class="line"> id INTEGER PRIMARY KEY,</span><br><span class="line"> old_id int,</span><br><span class="line"> new_id int,</span><br><span class="line"> old_phone text,</span><br><span class="line"> new_phone text,</span><br><span class="line"> old_email text,</span><br><span class="line"> new_email text,</span><br><span class="line"> user_action text,</span><br><span class="line"> created_at text</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>创建AFETER UPDATE触发器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER log_contact_after_update AFTER UPDATE ON leads</span><br><span class="line">WHEN old.phone &lt;&gt; new.phone</span><br><span class="line">OR old.email &lt;&gt; new.email</span><br><span class="line">BEGIN</span><br><span class="line"> INSERT INTO lead_logs (</span><br><span class="line"> old_id,</span><br><span class="line"> new_id,</span><br><span class="line"> old_phone,</span><br><span class="line"> new_phone,</span><br><span class="line"> old_email,</span><br><span class="line"> new_email,</span><br><span class="line"> user_action,</span><br><span class="line"> created_at</span><br><span class="line"> )</span><br><span class="line">VALUES</span><br><span class="line"> (</span><br><span class="line"> old.id,</span><br><span class="line"> new.id,</span><br><span class="line"> old.phone,</span><br><span class="line"> new.phone,</span><br><span class="line"> old.email,</span><br><span class="line"> new.email,</span><br><span class="line"> &#x27;UPDATE&#x27;,</span><br><span class="line"> DATETIME(&#x27;NOW&#x27;)</span><br><span class="line"> ) ;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>修改用户信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE leads</span><br><span class="line">SET last_name = &#x27;Smith&#x27;</span><br><span class="line">WHERE</span><br><span class="line"> id = 1;</span><br></pre></td></tr></table></figure><p>log_contact_after_update触发器不会执行，因为没有修改phone或者email字段的数据</p><p>更新用户的phone和email信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPDATE leads</span><br><span class="line">SET phone = &#x27;4089998888&#x27;,</span><br><span class="line"> email = &#x27;john.smith@sqlitetutorial.net&#x27;</span><br><span class="line">WHERE</span><br><span class="line"> id = 1;</span><br></pre></td></tr></table></figure><p>查看修改记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line"> old_phone, new_phone, old_email, new_email, user_action</span><br><span class="line">FROM</span><br><span class="line"> lead_logs;</span><br></pre></td></tr></table></figure><p>查询结果</p><p><img src="http://www.sqlitetutorial.net/wp-content/uploads/2015/12/SQLite-TRIGGER-After-Update-Trigger-Example.png" alt="SQLite TRIGGER After Update Trigger Example"></p><h4 id="SQLite触发器删除"><a href="#SQLite触发器删除" class="headerlink" title="SQLite触发器删除"></a>SQLite触发器删除</h4><p>使用DROP TRIGGER删除已经存在的触发器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TRIGGER [IF EXISTS] trigger_name;</span><br></pre></td></tr></table></figure><ol><li>指定需要删除的触发器名称</li><li>使用IF EXISTS防止删除不存在的触发器</li></ol><h5 id="删除触发器示例"><a href="#删除触发器示例" class="headerlink" title="删除触发器示例"></a>删除触发器示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TRIGGER validate_email_before_insert_leads;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本文简单介绍触发器的类型和使用，通过简单的示例演示触发器的使用，可以快速的上手使用SQLite触发器</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p> SQLite Trigger  </p><p><a href="http://www.sqlitetutorial.net/sqlite-trigger/">http://www.sqlitetutorial.net/sqlite-trigger/</a></p>]]></content>
    
    
    <categories>
      
      <category>sqlite3</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sqlite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++字节对齐方式</title>
    <link href="/2019/01/08/CPP%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F/"/>
    <url>/2019/01/08/CPP%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="C-字节对齐方式"><a href="#C-字节对齐方式" class="headerlink" title="C++字节对齐方式"></a>C++字节对齐方式</h3><h4 id="1-默认对齐方式"><a href="#1-默认对齐方式" class="headerlink" title="1. 默认对齐方式"></a>1. 默认对齐方式</h4><h5 id="1-1-结构体成员分别按自己的方式对齐"><a href="#1-1-结构体成员分别按自己的方式对齐" class="headerlink" title="1.1. 结构体成员分别按自己的方式对齐"></a>1.1. 结构体成员分别按自己的方式对齐</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct t1&#123;</span><br><span class="line">    char c1,  // c1长度1字节，采用1字节对齐</span><br><span class="line">    short s1, // s1长度2字节，采用2字节对齐</span><br><span class="line">    int i1,   // i1长度4字节，采用4字节对齐</span><br><span class="line">    char c2   // c2长度1字节，采用1字节对齐</span><br><span class="line">&#125;;</span><br><span class="line">sizeof(t1) = ？</span><br><span class="line"></span><br><span class="line">struct t1&#123;</span><br><span class="line">    char c1[2];</span><br><span class="line">    short s1;</span><br><span class="line">    int i1;</span><br><span class="line">    char c2[4]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><span id="more"></span><p>t1内存分布</p><table><thead><tr><th>c1</th><th>s1</th><th>i1</th><th>c2</th></tr></thead><tbody><tr><td>1*</td><td>11</td><td>1111</td><td>1***</td></tr></tbody></table><p>分析过程:</p><ul><li>c1是char类型并且是第一个成员变量，偏移地址为0，大小为1字节，分配内存1字节</li><li>s1为short类型，大小为2字节，采用自身对齐方式也就是2字节对齐，已经分配的内存为1字节不是2的整数倍，故在c1和s1中间插入一个空字符，然后为s1分配2字节空间，此时总分配空间大小为4字节</li><li>i1为int类型，大小为4字节，采用4字节对齐方式，已经分配的空间是4字节的整数倍，故不用插入空字符，给i1分配4字节，此时总分配空间大小为8字节</li><li>c2为char类型，大小为1字节，采用1字节对齐方式，已经分配的空间是1字节的整数倍，故不用插入空字符填充，给c2分配1字节空间，此时总空间大小为9字节</li><li>所有的成员变量已分配完，但t1采用的是4字节对齐方式，已分配的总空间不能被4整除，故在c2后添加3个空字节，最终分配的总空间为12字节，也就是sizeof(t1)等于12</li></ul><h5 id="1-2-复杂类型-包含结构体-的对齐方式是它最长的成员变量的对齐方式"><a href="#1-2-复杂类型-包含结构体-的对齐方式是它最长的成员变量的对齐方式" class="headerlink" title="1.2. 复杂类型(包含结构体)的对齐方式是它最长的成员变量的对齐方式"></a>1.2. 复杂类型(包含结构体)的对齐方式是它最长的成员变量的对齐方式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct t2 &#123;</span><br><span class="line">  char c1;    // 1字节</span><br><span class="line">  t1   t;     // 4字节</span><br><span class="line">  short s1;   // 2字节</span><br><span class="line">  int i1;     // 4字节</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>t2内存分布</p><table><thead><tr><th>c1</th><th>t</th><th>s1</th><th>i1</th></tr></thead><tbody><tr><td>1***</td><td>111111111111</td><td>11**</td><td>1111</td></tr></tbody></table><p>分析过程:</p><ul><li>c1 偏移地址为0，大小为1字节，分配1字节</li><li>t 中最长字节为4字节，对齐方式为4字节，故c1后填充3个空字符，然后分配t1内存空间，1 + 3 + 12 &#x3D; 16字节</li><li>s1大小2字节，对齐方式为2字节，已分配空间可以被2整除，不需要填充空字符，给s1分配2字节内存空间，16 + 2 &#x3D; 18字节</li><li>i1大小4字节，对齐方式为4字节，已分配的内存空间不能被4整除，需要在s1后填充2字节, 再给i1分配4字节空间，18 + 2 + 4 &#x3D; 24字节</li><li>t2的最终的对齐方式是4字节，分配的总空间能被4字节整除，最终分配的总空间为24字节，sizeof(t2)等于24</li></ul><p><strong>TODO</strong>: &#x3D;&#x3D;对齐后的长度必须是该类型的对齐字节数的整数倍&#x3D;&#x3D;</p><h4 id="2-自定义对齐方式"><a href="#2-自定义对齐方式" class="headerlink" title="2. 自定义对齐方式"></a>2. 自定义对齐方式</h4><p>设置自定义成员对齐后，同样要满足每个成员按自己的方式对齐，也就是说虽然指定对齐字节数,但并不是所有的成员都以指定对齐字节数来对齐。其对齐的规则是：每个成员按其类型的长度和指定对齐字节数中较小的一个对齐</p><h5 id="2-1-pragma-pack-n-与-pragma-pack"><a href="#2-1-pragma-pack-n-与-pragma-pack" class="headerlink" title="2.1. #pragma pack(n)与#pragma pack ()"></a>2.1. #pragma pack(n)与#pragma pack ()</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#pragma pack(n) // 编译器将按照n个字节对齐。</span><br><span class="line">#pragma pack()  // 取消自定义字节对齐方式(取消后恢复到编译器默认的对齐方式)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma pack(2)</span><br><span class="line">struct t3 &#123;</span><br><span class="line">    char c1;   // 长度1字节，&lt;2字节采用1字节对齐方式 </span><br><span class="line">    int i1;   // 长度4字节，&gt;2字节采用2字节对齐方式</span><br><span class="line">    short s1; // 长度2字节，=2字节采用2字节对齐方式</span><br><span class="line">    float f1; // 长度4字节，&gt;2字节采用2字节对齐方式</span><br><span class="line">    char c2;  // 长度1字节，&lt;2字节采用1字节对齐方式 </span><br><span class="line">    double d1;// 长度8字节，&gt;2字节采用2字节对齐方式</span><br><span class="line">    char c3;  // 长度1字节，&lt;2字节采用1字节对齐方式 </span><br><span class="line">&#125;;</span><br><span class="line">#pragma pack()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>t3内存分布</p><table><thead><tr><th>c1</th><th>i1</th><th>s1</th><th>f1</th><th>c2</th><th>d1</th><th>c3</th></tr></thead><tbody><tr><td>1*</td><td>1111</td><td>11</td><td>1111</td><td>1*</td><td>11111111</td><td>1*</td></tr></tbody></table><p>分析过程:</p><ul><li>c1 偏移0字节，大小为1字节，采用1字节对齐，分配内存空间1字节</li><li>i1 大小为4字节，采用设置的2字节对齐, c1后填空1个空字符后给i1分配4字节空间，1 + 1 + 4 &#x3D; 6</li><li>s1 大小为2字节，对齐方式为2字节，已分配空间能被2整除，故直接分配2字节空间， 6 + 2 &#x3D; 8</li><li>f1 大小为4字节，对齐方式为2字节，已分配空间能被2整除，故直接分配4字节空间， 8 + 4 &#x3D; 12</li><li>c2 大小为1字节，对齐方式为1字节，直接分配1字节空间， 12 + 1 &#x3D; 13</li><li>d1 大小为8字节，对齐方式为2字节，已分配空间不能被2整除，故在c2后填充1个空字符，再给d1分配8字节空间， 13 + 1 + 8 &#x3D; 22</li><li>c3 大小为1字节，对齐方式为1字节，直接分配1字节空间，22 + 1 &#x3D; 23</li><li>t3设置的对齐方式为2字节，已分配的内存空间不能被2整除，故在c3后再填充1个空字符， 23 + 1 &#x3D; 24， sizeof(t3) &#x3D; 24</li></ul><h5 id="2-2-pragma-pack-push-n-与-pragma-pack-pop"><a href="#2-2-pragma-pack-push-n-与-pragma-pack-pop" class="headerlink" title="2.2. #pragma pack (push,n)与#pragma pack(pop)"></a>2.2. #pragma pack (push,n)与#pragma pack(pop)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#pragma pack (push,n)    // 把原来对齐方式设置压栈，并设新的对齐方式为n个字节对齐</span><br><span class="line">#pragma pack(pop)        // 恢复原来对齐方式</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">// 采用默认的字节对齐方式, 即t1中最长的类型int, 即4字节对齐</span><br><span class="line">struct t1</span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line">    int i;</span><br><span class="line">    short s;</span><br><span class="line">    float f;</span><br><span class="line">    char c1;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">#pragma pack(2)         // 编译器将按照2个字节对齐</span><br><span class="line"> </span><br><span class="line">    // 2字节对齐</span><br><span class="line">    struct t2   </span><br><span class="line">    &#123;</span><br><span class="line">        char c;</span><br><span class="line">        int i;</span><br><span class="line">        short s;</span><br><span class="line">        float f;</span><br><span class="line">        char c1;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    #pragma pack(push, 1)  // 把原来对齐方式(2字节)置压栈，并设新对齐方式为1字节</span><br><span class="line"> </span><br><span class="line">        // 1字节对齐</span><br><span class="line">        struct t3   </span><br><span class="line">        &#123;</span><br><span class="line">            char c;</span><br><span class="line">            int i;</span><br><span class="line">            short s;</span><br><span class="line">            float f;</span><br><span class="line">            char c1;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        #pragma pack(2)     // 编译器将按照2个字节对齐</span><br><span class="line"> </span><br><span class="line">            // 2字节对齐</span><br><span class="line">            struct t4      </span><br><span class="line">            &#123;</span><br><span class="line">                char c;</span><br><span class="line">                int i;</span><br><span class="line">                short s;</span><br><span class="line">                float f;</span><br><span class="line">                char c1;</span><br><span class="line">            &#125;;</span><br><span class="line"> </span><br><span class="line">        #pragma pack()      // 取消自定义字节对齐(2字节)方式, 采用默认字节对齐方式</span><br><span class="line"> </span><br><span class="line">        // 采用默认的字节对齐方式, 即t5中最长的类型int, 即4字节对齐</span><br><span class="line">        struct t5       </span><br><span class="line">        &#123;</span><br><span class="line">            char c;</span><br><span class="line">            int i;</span><br><span class="line">            short s;</span><br><span class="line">            float f;</span><br><span class="line">            char c1;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    #pragma pack(pop)       // 取消1字节对齐方式。恢复到原来的2个字节对齐方式</span><br><span class="line"> </span><br><span class="line">    // 2字节对齐</span><br><span class="line">    struct t6       </span><br><span class="line">    &#123;</span><br><span class="line">        char c;</span><br><span class="line">        int i;</span><br><span class="line">        short s;</span><br><span class="line">        float f;</span><br><span class="line">        char c1;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">#pragma pack()          // 取消自定义字节对齐(2个字节)方式, 采用默认的字节对齐方式</span><br><span class="line"> </span><br><span class="line">// 采用默认的字节对齐方式, 即t7中最长的类型int, 即4字节对齐</span><br><span class="line">struct t7   </span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line">    int i;</span><br><span class="line">    short s;</span><br><span class="line">    float f;</span><br><span class="line">    char c1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-字节不对齐的坏处"><a href="#3-字节不对齐的坏处" class="headerlink" title="3. 字节不对齐的坏处"></a>3. 字节不对齐的坏处</h4><ul><li>某些架构的CPU访问没有对齐的变量可能会引发错误</li><li>降低读取变量的效率</li><li>影响跨平台代码移植</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
